{"meta":{"title":"huzai9527's personal blog","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[{"title":"Tags","date":"2020-06-30T12:29:17.407Z","updated":"2020-06-30T12:29:17.407Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"PWN-堆相关的漏洞","slug":"PWN-堆相关的漏洞","date":"2020-12-12T04:30:57.000Z","updated":"2020-12-12T04:45:01.356Z","comments":true,"path":"2020/12/12/PWN-堆相关的漏洞/","link":"","permalink":"http://yoursite.com/2020/12/12/PWN-堆相关的漏洞/","excerpt":"","text":"三、堆相关的漏洞1.堆介绍 结构示意图 N位：define NON_MAIN_ARENA 用于表示是否属于主线程，0表示主线程的堆块结构，1表示子线程的堆块结构 M位：define IS_MAPPED 0X2 用于表示是否由mmap分配，0表示由堆块中的top chunk分裂产生，1表示由mmap分配 P位：define PREV_ISUSE 0x1 用于表示上一堆块是否处于空闲状态，0表示处于空闲状态，1表示处于使用状态。主要用于来判断free是否能够上一堆块进行合并 堆空闲块管理结构bin 当allocated chunk被释放以后，会放入bin或者top chunk中去。bin的作用是加快分配速度，其通过链表方式（chunk结构体中的fd和bk指针）进行管理 fast bin 单链表结构进行组织，用fd指针指向下一堆块，采用LIFO机制 它将堆块的p标志为都设为1，处于占用状态，以防止释放时fast bin进行合并，用于快速分配小内存 malloc基本规则 将申请size按照一定的规则对齐，得到最终要分配的大小size_real X86:size+4 按照0x10字节对齐 X64：size+8按照0x20字节对齐 检查size_real 是否符合fast bin 的大小，若是则查看fast bin中对应的size_real 的那条链表中是否存在堆块，若是则分配，否则进行下一步 检查size-real 是否符合small bin 的大小，若是则查看fast bin中对应的size_real 的那条链表中是否存在堆块，若是则分配，否则进行下一步 检查size-real 是否符合large bin 的大小，若是则调用malloc_consolidate函数对fast bin中所有堆块进行合并，其过程为将fast bin中的堆块取出，清除下一块的p标识位并进行堆块合并，将最终的堆块放入unsorted bin。然后在small bin 和large bin中找到合适size_real大小的块。若找到则分配，并将多余的部分放入unsorted bin ，否则下一步 检查top chunk的大小是否符合size_real的大小，若是则分配前面一部分，并重新设置top chunk，否则调用malloc_consolidate函数对fast bin中所有的堆块进行合并，若依然不否，则借助系统调用来开辟新的空间进行分配，若还是不满足，则返回失败 free 基本规则 首先会检查地址是否对齐,并根据size找到下一块的位置,检查其p标识位是否为1 检查释放块的size是否符合fastbin的大小区间,若是则直接放入fast bin,并保持下一堆块中的p标识位为1不变(这样可以避免在前后块释放时进行堆块的合并,以方便快速分配小内存),否则进行下一步 若本堆块size域中的p标识位为0(前一堆块处于释放状态)则利用本快的pre_size找到前一堆块的开头,将其从bin链表中摘除(unlink),并合并这两个块,得到新的释放块 根据size找到下一堆块,如果是top chunk,则直接合并到top chunk中,直接返回.否则检查最后一堆块是否处于释放状态(通过检查下一堆块的p标识位是否为0).将其从bin链表中摘除(unlink),并合并这两块,得到新的释放块. 将上述合并得到的最终堆块放入unstorted bin中去 tcache 作用 提高堆的使用效率 注意点 tcache的管理是单链表,采用LIFO原则 tcache的管理结构存在于堆中,默认有64个entry,每个entry最多存放7个chunk tcache的next指针指向chunk的数据区 tcache的某个entry被占满以后,符合该entry大小的chunk被free后的规则和原有机制相同 2. 相关的数据结构微观结构malloc_chunk结构 1234567891011121314151617/* This struct declaration is misleading (but accurate and necessary). It declares a \"view\" into memory allowing access to necessary fields at known offsets from a given base. See explanation below.*/struct malloc_chunk &#123; INTERNAL_SIZE_T prev_size; /* Size of previous chunk (if free). */ INTERNAL_SIZE_T size; /* Size in bytes, including overhead. */ struct malloc_chunk* fd; /* double links -- used only if free. */ struct malloc_chunk* bk; /* Only used for large blocks: pointer to next larger size. */ struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */ struct malloc_chunk* bk_nextsize;&#125;; Bin ptmalloc 根据chunk的大小以及使用状态将chunk分为4类:fast bin, small bin, large bin, unstorted bin 一个bin相当于一个chunk链表 fast bin 采用LIFO策略,支持的最大的chunk的数据空间大小为64字节,最大支持的bin的个数位10,inuse位始终置为1,防止被合并 small bins中每个chunk的大小与其所在bin的index的关系为:chunk_size = 2*size_sz*index Top Chunk程序第一次进行malloc的时候,heap会被分成两块,一块给用户,剩下的那块就是Top Chunk(处于当前堆的物理地址最高的chunk,不属于任何bin),它的作用是在当前所有bin都无法满足用户的请求大小时,如果其满足大小,就进行分配,将剩下的部分作为新的TopChunk.否则对heap进行扩展后再进行分配. 宏观结构heap_info​ 程序刚开始执行时是没有heap区域的,当其申请内存时,就需要一个结构记录对应的信息,而且一般当前的heap资源被用完后,重新申请的heap一般是不连续的,因此需要记录不同heap之间连接结构,而heap的作用就是这个 malloc_state该结构用于管理堆,记录每个arena当前申请内存的具体状态,比如是否有空闲的chunk等,他是一全局变量存储在libc.so中 3.深入理解堆的实现宏观角度 - 创建堆 - 堆初始化 - 删除堆 微观角度 申请内存块 释放内存块 3.相关的漏洞1. 最基本的堆漏洞 由于对堆内容类型判断不明而形成的错误引用,通常情况下,可以使用堆块存储复杂的结构体,其中可能会包括函数指针、变量、数组等成员.如果一个结构体数据按照其他结构体格式来解析,那么只要在特定的域布置好数据,就会导致漏洞的发生. 2.堆缓冲区溢出 常规溢出 堆缓冲区溢出与栈缓冲区溢出类似 Off By One 只能溢出一子节,通常位于堆块末尾,溢出的1子节恰好能够覆盖下一堆块的size域的最低位,难以利用,一般有固定的套路 Use After Free 若堆指针在释放后未被置空,形成悬挂指针(野指针),当下次访问该指针时,依然能够访问到原始指针指向的堆内容 申请一段空间,并将其释放,释放后并不将指针置为空,因此这个指针仍然可以使用,把这个指针简称为p1 申请空间p2,由于malloc分配过程使得p2指向的空间为刚刚释放的p1指针的空间,构造恶意数据将这段内存空间布局好,既覆盖p1中的数据 可利用p1,一般多有一个函数指针,由于之前已经使用P2将P1中的数据覆盖了,所以此时的数据即是我们可以控制的,既存在劫持函数流的情况 Doubble Free 对指针进行多次释放.多次释放会使堆块发生重叠,前后申请的堆块可能会指向同一块内存","categories":[],"tags":[{"name":"CTF PWN","slug":"CTF-PWN","permalink":"http://yoursite.com/tags/CTF-PWN/"}]},{"title":"PWN-堆栈平衡","slug":"PWN-堆栈平衡","date":"2020-12-12T04:23:21.000Z","updated":"2020-12-12T04:29:53.847Z","comments":true,"path":"2020/12/12/PWN-堆栈平衡/","link":"","permalink":"http://yoursite.com/2020/12/12/PWN-堆栈平衡/","excerpt":"","text":"堆栈平衡和栈转移1.栈平衡1.为什么需要堆栈平衡? 保持栈的大小,是ESP始终指向栈顶 2.概念 函数如果要返回父程序,则在堆栈中进行操作时,一定要在RET指令之前,将ESP指向函数压入栈中时的地址 如果通过堆栈传递参数了,那么在函数执行完毕后,要平衡参数导致的堆栈变化 3.总结 当函数在栈中操作时,需要先把ESP交给EBP,然后继续操作,当操作完成后,在ret之前,要先将ESP恢复成进入栈之前的状态,最后再将EBP移除栈 2.栈转移1.为什么需要栈转移? 在栈空间不够存放payload的情况下,需要一个新的地址空间存放payload 开启PIE保护,栈地址未知,我们可以将栈劫持到已知的区域 2.概念 劫持栈的rsp(ESP),使其指向其他位置,形成一个伪造的栈,在此栈中做ROP 3.必要的gadget pop ebp;ret 释放EBP,并连接伪造的栈 leave;ret 更改ESP,指向后续的payload 4.原理 通过 pop ebp;ret + 伪造的栈让程序直接跳转到伪造的栈里面,然后为了保持栈平衡,从而执行 leave ;ret,最后继续执行伪造栈内的payload 5.过程 使用输入函数(如read),将后续的payload加载到bss段内,也就是伪造的栈 通过 pop ebp;ret | pop ebx;ret 来调整EBP寄存器 通过 leave ret; 来更改 ESP,使其指向伪造的栈 然后在伪造的栈中执行下一段ROP","categories":[],"tags":[{"name":"PWN CTF","slug":"PWN-CTF","permalink":"http://yoursite.com/tags/PWN-CTF/"}]},{"title":"PWN-常见危险函数","slug":"PWN-常见危险函数","date":"2020-12-12T04:19:32.000Z","updated":"2020-12-12T04:25:50.279Z","comments":true,"path":"2020/12/12/PWN-常见危险函数/","link":"","permalink":"http://yoursite.com/2020/12/12/PWN-常见危险函数/","excerpt":"","text":"CTF-PWN常见的危险函数 gets() 没有检查边界 通过计算函数的偏移量,通过构造payload达到溢出 fgets(buf, 40, stdin) 能够接受39Byte,最后一个字节为NULL 如果buf的长度没有39也可以造成溢出 read(stdin, buf, 40) 从输入中读取40个Byte,到buf,最后的字节可以不是NULL 可能会造成信息的泄漏 read(0,buf,0x20) 从用户输入读取32个字符 Write(int fd, buf, nbytes) fd 输出描述 1 buf 为要写入到数据的缓冲区地址 nbytes为要写入的数据的字节数 strcpy memcpy scanf（“%s”，buff） syscall系统调用 操作系统实现系统调用的基本过程是: 应用程序调用库函数(API) API将系统调用号存入EAX,然后通过中断调用使系统进入内核态 内核中终端处理函数根据系统调用号,调用对应的内核函数(系统调用) 系统调用完成相应的功能,将返回值存入EAX,返回到中断处理函数 中断处理函数返回到API中 API将EAX返回给应用程序 应用程序调用系统调用的过程 把系统调用的编号存入EAX 把函数参数存入其他通用寄存器 触发0x80号中断(int 0x80) 以上是32位的系统调用,与64 位的区别是 传参方式不同 32位 先将系统调用号传入eax,然后将参数从左到右依次存入ebx,ecx,edx寄存器中,返回值存在eax中 64位 先将系统调用号传入rax,然后传参数 从左到右依次存入rdi,rsi,rdx寄存器中,返回值存在rax寄存器 系统调用号不同 32位 sys_read 的系统调用号为 30 sys_write 的系统调用号为4 64位 sys_read的调用号位0,sys_write的调用号为1亿 调用方式不同 ​ 32位 使用int 80 中断进行系统调用 64位 使用syscall进行系统调用","categories":[],"tags":[{"name":"PWN CTF","slug":"PWN-CTF","permalink":"http://yoursite.com/tags/PWN-CTF/"}]},{"title":"东南大学无锡分校青年大学习统计","slug":"东南大学青年大学习统计","date":"2020-10-21T07:06:45.000Z","updated":"2020-10-21T07:23:22.461Z","comments":true,"path":"2020/10/21/东南大学青年大学习统计/","link":"","permalink":"http://yoursite.com/2020/10/21/东南大学青年大学习统计/","excerpt":"","text":"东南大学青年大学习统计运行截图 环境安装 你可以按照下面的方式下载代码到本地 1git clone --depth 1 https://github.com/huzai9527/studyAnalysis.git SUSmember-dev 本项目在python 3 下运行,并且依赖pands,你可以在终端运行以下命令进行安装 1pip install pandas 所需要的文件以及格式 本院总名单,按照如下格式,首行为班级名称,首列为索引号(excel自带),将班级同学名字替换即可 班级累计分数:首行为列名第一列列名空,第二列列名累计分数 第一列为填班级名,第二列为保存的班级名 最后是大学习的统计情况,此文件是上级下发的,只要移到此目录即可 注: 总名单以及班级累计分数可以在下载好的文件中直接修改 安装好环境以及准备好相应文件后,在终端运行(文件目录路径下)1python SUSmember.py 无锡分校-东南-第十一期 运行完成输出，各班详细情况，并在结果文件夹生成EXCELL统计文件 有不是团员的只要在总名单中删除即可","categories":[],"tags":[{"name":"数据分析","slug":"数据分析","permalink":"http://yoursite.com/tags/数据分析/"}]},{"title":"SSM框架整合","slug":"SSM框架整合","date":"2020-10-16T21:15:57.000Z","updated":"2020-10-16T21:16:11.964Z","comments":true,"path":"2020/10/17/SSM框架整合/","link":"","permalink":"http://yoursite.com/2020/10/17/SSM框架整合/","excerpt":"","text":"SSM框架整合导入相关的依赖 pom.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;ssmBuild&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt;&lt;!-- mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.5&lt;/version&gt; &lt;/dependency&gt;&lt;!-- 数据库驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.49&lt;/version&gt; &lt;/dependency&gt;&lt;!-- 数据库连接池--&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.5&lt;/version&gt; &lt;/dependency&gt;&lt;!-- spring--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.12&lt;/version&gt; &lt;/dependency&gt;&lt;!-- junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resource&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt;&lt;/project&gt; 整合mybatis db.properties 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.username=rootjdbc.password=asdqwe123.jdbc.url=jdbc:mysql://localhost:3306/ssmbuild?useUnicode=true&amp;characterEncoding=utf8 Mybatis-config.xml 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt;&lt;!--配置数据源，spring代理了--&gt;&lt;!-- 配置别名--&gt; &lt;typeAliases&gt; &lt;package name=\"com.huzai.pojo\"/&gt; &lt;/typeAliases&gt;&lt;!-- mapper扫描--&gt; &lt;mappers&gt; &lt;package name=\"com.huzai.dao\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; Spring-dao.xml 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt;&lt;!-- 关联数据库配置文件--&gt; &lt;context:property-placeholder location=\"classpath:db.properties\"/&gt;&lt;!-- 连接池--&gt; &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;property name=\"user\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt; &lt;property name=\"jdbcUrl\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"maxPoolSize\" value=\"30\"/&gt; &lt;property name=\"minPoolSize\" value=\"10\"/&gt; &lt;property name=\"checkoutTimeout\" value=\"10000\"/&gt; &lt;property name=\"autoCommitOnClose\" value=\"false\"/&gt; &lt;property name=\"acquireRetryAttempts\" value=\"2\"/&gt; &lt;/bean&gt;&lt;!-- sqlSessionFactory--&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;&lt;!-- 绑定mybatis配置文件--&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/&gt; &lt;/bean&gt;&lt;!-- 配置dao接口扫描包，动态实现dao接口注入spring容器中--&gt; &lt;bean id=\"mapperScannerConfigurer\" class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt;&lt;!-- 注入sqlSessionFactory--&gt; &lt;property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"/&gt;&lt;!-- 需要扫描的dao包--&gt; &lt;property name=\"basePackage\" value=\"com.huzai.dao\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 整合spring spring-service.xml 123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt;&lt;!-- 要扫描的service下的包--&gt; &lt;context:component-scan base-package=\"com.huzai.service\"/&gt;&lt;!-- 将所有的业务类，注入到spring容器中，可以配置实现，也可以注解实现--&gt;&lt;!-- &lt;bean id=\"bookServiceImpl\" class=\"com.huzai.service.bookServiceImpl\"&gt;--&gt;&lt;!-- &lt;property name=\"bookMapper\" ref=\"bookMapper\"/&gt;--&gt;&lt;!-- &lt;/bean&gt;--&gt;&lt;!-- 声明事物配置--&gt; &lt;bean id=\"dataSourceTransactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;!-- 注入数据源--&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;/bean&gt;&lt;!-- aop事物支持--&gt;&lt;/beans&gt; 整合spring-mvc spring-mvc.xml 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt;&lt;!-- 注解驱动--&gt; &lt;mvc:annotation-driven/&gt;&lt;!-- 静态资源过滤--&gt; &lt;mvc:default-servlet-handler/&gt;&lt;!-- 扫描包--&gt; &lt;context:component-scan base-package=\"com.huzai.controller\"/&gt;&lt;!-- 试图解析器--&gt; &lt;bean id=\"internalResourceViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt;&lt;/beans&gt; applicationContext.xml 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;import resource=\"classpath:spring-service.xml\"/&gt; &lt;import resource=\"classpath:spring-dao.xml\"/&gt; &lt;import resource=\"classpath:spring-mvc.xml\"/&gt;&lt;/beans&gt; web.xml 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt;&lt;!-- DispatcherServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;!-- 乱码过滤--&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;!-- session--&gt; &lt;session-config&gt; &lt;session-timeout&gt;12&lt;/session-timeout&gt; &lt;/session-config&gt;&lt;/web-app&gt;","categories":[],"tags":[]},{"title":"SpringMVC学习总结","slug":"SpringMVC学习总结","date":"2020-10-16T21:15:18.000Z","updated":"2020-10-16T21:15:37.691Z","comments":true,"path":"2020/10/17/SpringMVC学习总结/","link":"","permalink":"http://yoursite.com/2020/10/17/SpringMVC学习总结/","excerpt":"","text":"SprngMVC学习总结HelloSpringMvc遇到的问题 Tomcat中没有相应的jar包,需要导入! controller在注册时的id,就是url中的参数,需要保持一致 使用注解进行开发123456&lt;!-- 自动扫描包，让指定包下的注解生效--&gt; &lt;context:component-scan base-package=\"com.huzai.controller\"/&gt;&lt;!-- 让SpringMVC不处理静态资源--&gt; &lt;mvc:default-servlet-handler/&gt;&lt;!-- 自动注入--&gt; &lt;mvc:annotation-driven/&gt; RestFull风格url路径中参数的携带123456@RequestMapping(value = \"/add/&#123;a&#125;/&#123;b&#125;\", method = RequestMethod.GET)public String add(@PathVariable int a,@PathVariable int b, Model model)&#123; int result = a+b; model.addAttribute(\"msg\",result); return \"hello\";&#125; JSON的使用jackson 依赖(需要将其jar包导入tomcat的依赖) 12345&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.11.3&lt;/version&gt;&lt;/dependency&gt; 使用(可以在大环境下使用@RestController) 12345678@RequestMapping(\"/json\")@ResponseBodypublic String json() throws JsonProcessingException &#123; ObjectMapper objectMapper = new ObjectMapper(); Date date = new Date(); String str = objectMapper.writeValueAsString(date); return str;&#125; fastjson 依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.73&lt;/version&gt; &lt;/dependency&gt; 使用 1234567891011 @RequestMapping(\"/fastJson\") @ResponseBody public String fastJson()&#123;// fastJson 有很多功能其实都可以用jackson扩展写// java对象转JSON字符串JSON.toJSONString// JSON字符串转JAVA对象JSON.parseObject() Date date = new Date(); String json = JSON.toJSONString(date); return json; &#125; 乱码问题Web中的乱码 在web.xml中进行配置 12345678&lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; Jackson中的乱码 在springMVC的配置文件中进行配置 12345678910111213&lt;!-- 自动注入,JSON乱码问题配置--&gt;&lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults=\"true\"&gt; &lt;bean class=\"org.springframework.http.converter.xml.SourceHttpMessageConverter\"/&gt; &lt;bean class=\"org.springframework.http.converter.cbor.MappingJackson2CborHttpMessageConverter\"&gt; &lt;property name=\"objectMapper\"&gt; &lt;bean class=\"org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean\"&gt; &lt;property name=\"failOnEmptyBeans\" value=\"false\"/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt; fastjson中的乱码1234567891011&lt;mvc:annotation-driven&gt; &lt;mvc:message-converters&gt; &lt;bean class=\"org.springframework.http.converter.StringHttpMessageConverter\"&gt; &lt;property name=\"supportedMediaTypes\"&gt; &lt;list&gt; &lt;value&gt;application/json;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt; springMVC中的全部配置文件web.xml12345678910111213141516171819202122232425262728293031&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;servlet&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; Springmvc-servlet.xml123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!-- 自动扫描包，让指定包下的注解生效--&gt; &lt;context:component-scan base-package=\"com.huzai.controller\"/&gt; &lt;!-- 让SpringMVC不处理静态资源--&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!-- 自动注入,JSON乱码问题配置--&gt; &lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults=\"true\"&gt; &lt;bean class=\"org.springframework.http.converter.xml.SourceHttpMessageConverter\"/&gt; &lt;bean class=\"org.springframework.http.converter.cbor.MappingJackson2CborHttpMessageConverter\"&gt; &lt;property name=\"objectMapper\"&gt; &lt;bean class=\"org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean\"&gt; &lt;property name=\"failOnEmptyBeans\" value=\"false\"/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"internalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt;&lt;/beans&gt;","categories":[],"tags":[]},{"title":"Spring学习总结","slug":"Spring学习总结","date":"2020-10-16T21:09:51.000Z","updated":"2020-10-16T21:10:02.595Z","comments":true,"path":"2020/10/17/Spring学习总结/","link":"","permalink":"http://yoursite.com/2020/10/17/Spring学习总结/","excerpt":"","text":"Spring课堂记录SpringIOC理论推导 UserDao UserDaoImpl UserService UserServiceImpl 在之前的业务中,用户的需求可能会影响我们的源代码,我们要根据用户的需求修改源代码,如果代码量非常大,修改一次的成本十分昂贵! 使用一个Set接口,利用set进行动态值的注入,会发生革命性的变化! 123public void setHello(Hello hello) &#123; this.hello = hello;&#125; 之前,是程序主动创造对象!控制权在程序员手上! 使用set注入后,程序不在具有主动性,而是变成了被动的接受对象! 这种思想,从本质上解决了问题,程序员不用再去管理对象的创建.系统的耦合性大大降低,可以使程序猿更加专注在业务的实现上!这是IOC的原型! IOC实现 An architecture for end-to-end and inter-domain trusted mail delivery service 配置 在beans.xml 中配置注册pojo类,将这些类交给spring进行管理 12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- more bean definitions go here --&gt;&lt;/beans&gt; 使用beans 12345678// create and configure beansApplicationContext context = new ClassPathXmlApplicationContext(\"services.xml\", \"daos.xml\");// retrieve configured instancePetStoreService service = context.getBean(\"petStore\", PetStoreService.class);// use configured instanceList&lt;String&gt; userList = service.getUsernameList(); bean中的参数 id:bean的唯一标识 class:bean绑定的pojo对象 autowire:通过set方法中的属性自动装配其他的bean 依赖注入 构造器注入 set注入 依赖:bean对象的创建依赖与容器! 注入:bean对象的所有属性有容器注入! 拓展方式注入 1234567891011121314&lt;bean id=\"exampleBean\" class=\"examples.ExampleBean\"&gt; &lt;!-- constructor injection using the nested ref element --&gt; &lt;constructor-arg&gt; &lt;ref bean=\"anotherExampleBean\"/&gt; &lt;/constructor-arg&gt; &lt;!-- constructor injection using the neater ref attribute --&gt; &lt;constructor-arg ref=\"yetAnotherBean\"/&gt; &lt;constructor-arg type=\"int\" value=\"1\"/&gt;&lt;/bean&gt;&lt;bean id=\"anotherExampleBean\" class=\"examples.AnotherBean\"/&gt;&lt;bean id=\"yetAnotherBean\" class=\"examples.YetAnotherBean\"/&gt; bean的作用域 ==单例模式==(spring默认机制) :这全局唯一,永远只创建一个实例 1234&lt;bean id=\"accountService\" class=\"com.something.DefaultAccountService\"/&gt;&lt;!-- the following is equivalent, though redundant (singleton scope is the default) --&gt;&lt;bean id=\"accountService\" class=\"com.something.DefaultAccountService\" scope=\"singleton\"/&gt; 原型模式:每次都会产生一个新的对象 1&lt;bean id=\"accountService\" class=\"com.something.DefaultAccountService\" scope=\"prototype\"/&gt; #### Spring注解开发applicationContext.xml配置文件12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:component-scan base-package=\"com.huzai.pojo\"/&gt; &lt;context:annotation-config/&gt;&lt;/beans&gt; bean的注入包括 在pojo中直接用[@Component] 在service中使用[@Service] 在dao使用[@Repository] 在controller使用[@Controller] 值与对象的注入 [@Value(“huzai”)]对值的注入 [@Scope(“protoType”)]作用域的注入 [@Autowired] 对对象中的对象的注入 [@Qualifier(value = “dog”)] 配合@Autowired使用,指定精确的注入对象 123456@Value(\"huzai\")private String name;@Nullable@Autowired@Qualifier(value = \"dog\")private Dog dog; [@Nullable]表明字段可以为空 完全不用xml配置的注解开发 配置用config.java(相当于beans.xml) 123456789101112@Configuration@ComponentScanpublic class MyConfig &#123; //注册一个bean,相当于一个bean的标签 //方法的名字相当于bean标签中的id属性 //方法的返回值相当于bean标签中的class属性 // @Bean public User getUser()&#123; return new User(); &#125;&#125; 代理模式静态代理静态代理也就是项目横向开发的过程,在此过程中,猿们无需改变以前的代码,因为这是公司中的大忌. 角色分析 抽象角色:一般使用接口或抽象类来解决 真实角色:被代理的角色 代理角色:代理真实角色,一般有一些附属操作 客户:访问代理对象的人 代码步骤 接口 真实角色 代理角色 客户端访问 代理模式的好处 可以是真实角色的操作更加纯粹,不用关心其他公共业务 公共业务可以交给代理角色!实现了业务的分工! 公共业务发生集中在一起,方便管理 缺点 一个真实角色产生一个代理,代码量翻倍,开发效率变低 动态代理 角色与静态代理一样 代理动态生成 分为两大类 基于接口 – JDK’动态代理 基于类 – cglib 基于java字节码 – javassit 优点 除了静态代理的 一个动态代理类可以代理多个类,只要实现了对应的借口 一个动态代理类代理的是一个接借口,一般对应的是一类业务 AOP在Spring中的作用==提供声明式事物;允许用户自定义切面== Spring中实现AOP AOP依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.6&lt;/version&gt;&lt;/dependency&gt; 配置文件:applicationContext.xml 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;context:component-scan base-package=\"com.huzai\"/&gt; &lt;context:annotation-config/&gt; &lt;aop:aspectj-autoproxy/&gt;&lt;/beans&gt; 方式 方式一:使用Spring API接口 1234&lt;aop:config&gt; &lt;aop:pointcut id=\"pointcut\" expression=\"execution(* com.huzai.service.UserServiceImpl.*(..))\"/&gt; &lt;aop:advisor advice-ref=\"log\" pointcut-ref=\"pointcut\"/&gt;&lt;/aop:config&gt; 方式二:自定义类 1234567&lt;!-- 方式二：使用自定义类--&gt; &lt;aop:config&gt; &lt;aop:aspect ref=\"diyPointCut\"&gt; &lt;aop:pointcut id=\"pointcut\" expression=\"execution(* com.huzai.service.*.*(..))\"/&gt; &lt;aop:before method=\"before\" pointcut-ref=\"pointcut\"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 方式三:使用注解开发 12345678@Component@Aspectpublic class AnnotationPoint &#123; @Before(\"execution(* com.huzai.pojo.User.* (..))\") public void before()&#123; System.out.println(\"====开始====\"); &#125;&#125; Spring整合Mybatis使用Spring 的数据源 参数包括连接数据库的所有参数 以及对数据进行约束的数据源自带的约束 一般的数据源包括 c3p0、druid、dbcp 123456&lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis? useSSL=false&amp;amp;useUnicode=true&amp;amp;encoding=utf8\"/&gt; &lt;property name=\"password\" value=\"asdqwe123.\"/&gt;&lt;/bean&gt; 构造SqlsessionFactory 需要设置如下的参数 数据源dataSource 加载mybatis的配置文件 mapperLocation的地址 12345&lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatisConfig.xml\"/&gt; &lt;property name=\"mapperLocations\" value=\"classpath:com/huzai/mapper/*.xml\"/&gt;&lt;/bean&gt; 构造SqlsessionTemplete(sqlsession) 需要将其注入到ServiceImpl 123&lt;bean id=\"sqlSessionTemplate\" class=\"org.mybatis.spring.SqlSessionTemplate\"&gt; &lt;constructor-arg index=\"0\" ref=\"sqlSessionFactory\"/&gt;&lt;/bean&gt; 声明式事物事物: 要么都成功,要么都失败! 涉及到数据的一致性问题 确保完整性和一致性 事物的ACID原则; 原子性 一致性 隔离性 多个业务可能操作同一个资源,防止数据损害 持久性 Spring中的事物管理申明式事物:AOP配置申明式事物123 &lt;bean id=\"dataSourceTransactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;constructor-arg ref=\"dataSource\"/&gt;&lt;/bean&gt; 结合aop实现的事物的织入 配置事务通知 1234567 &lt;tx:advice id=\"txAdvice\" transaction-manager=\"dataSourceTransactionManager\"&gt;&lt;!-- 给那些方法配置事物--&gt;&lt;!-- 配置事物的传播特性--&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"add\" propagation=\"REQUIRED\"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; 配置事务切入 123456&lt;!-- 配置事物的切入--&gt; &lt;aop:config&gt; &lt;aop:pointcut id=\"txPointCut\" expression=\"execution(* com.huzai.mapper.*.*(..))\"/&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"txPointCut\"/&gt; &lt;/aop:config&gt; 编程式事物:需要在代码中进行事物的管理所有的配置文件头12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:jdbc=\"http://www.springframework.org/schema/jdbc\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\"&gt;&lt;/beans&gt; 所有的dependency123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.49&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.5&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resource&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt;","categories":[],"tags":[]},{"title":"Mybatis学习总结","slug":"Mybatis学习总结","date":"2020-10-16T21:09:05.000Z","updated":"2020-10-16T21:09:14.942Z","comments":true,"path":"2020/10/17/Mybatis学习总结/","link":"","permalink":"http://yoursite.com/2020/10/17/Mybatis学习总结/","excerpt":"","text":"Mybatis 学习总结基本环境配置1.Mybatis-config.xml 配置参数按照如此下顺序配置- properties/settings/typeAliases/typeHandlers/objectFactory/objectWrapperFactory/plugins/environments/databaseIdProvider/mappers 所有的*Mapper.xml需要在Mapper中注册 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=\"org/mybatis/example/BlogMapper.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 2.构建sqlsessionFactory123String resource = \"org/mybatis/example/mybatis-config.xml\";InputStream inputStream = Resources.getResourceAsStream(resource);SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); 3.*Mapper.xml 命名空间必须指向方法的接口 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"org.mybatis.example.BlogMapper\"&gt; &lt;select id=\"selectBlog\" resultType=\"Blog\"&gt; select * from Blog where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 于此同时，我们也可以通过注解对一些简单的sql语句映射 12345package org.mybatis.example;public interface BlogMapper &#123; @Select(\"SELECT * FROM blog WHERE id = #&#123;id&#125;\") Blog selectBlog(int id);&#125; XML配置1. properties 加载外部配置文件 1234&lt;properties resource=\"org/mybatis/example/config.properties\"&gt; &lt;property name=\"username\" value=\"dev_user\"/&gt; &lt;property name=\"password\" value=\"F2Fa3!33TYyg\"/&gt;&lt;/properties&gt; 3.typeAliases 设置别名 可以为每个pojo设置；也可以直接指定包名，mybatis会扫描package下面所有的javabean；也可以通过注解 123&lt;typeAliases&gt; &lt;package name=\"domain.blog\"/&gt;&lt;/typeAliases&gt; 4.environments 尽管可以配置多个数据库环境，但每个SqlsessionFactory只能选择一种环境 12345678910111213&lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"&gt; &lt;property name=\"...\" value=\"...\"/&gt; &lt;/transactionManager&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt; 5.mappers 告诉mybatis到哪里寻找配置文件。可以通过直接指定xml文件；也可以通过加载同名class；还可以通过扫描mapper所在的package。 1234&lt;!-- 将包内的映射器接口实现全部注册为映射器 --&gt;&lt;mappers&gt; &lt;package name=\"org.mybatis.builder\"/&gt;&lt;/mappers&gt; XML映射文件 cache – 该命名空间的缓存配置。 cache-ref – 引用其它命名空间的缓存配置。 resultMap – 描述如何从数据库结果集中加载对象，是最复杂也是最强大的元素。 解决pojo中属性名与数据库中列名不想等的情况 12345&lt;resultMap id=\"userResultMap\" type=\"User\"&gt; &lt;id property=\"id\" column=\"user_id\" /&gt; &lt;result property=\"username\" column=\"user_name\"/&gt; &lt;result property=\"password\" column=\"hashed_password\"/&gt;&lt;/resultMap&gt; 12345&lt;select id=\"selectUsers\" resultMap=\"userResultMap\"&gt; select user_id, user_name, hashed_password from some_table where id = #&#123;id&#125;&lt;/select&gt; 多对一的映射 12345678&lt;association property=\"author\" javaType=\"Author\"&gt; &lt;id property=\"id\" column=\"author_id\"/&gt; &lt;result property=\"username\" column=\"author_username\"/&gt; &lt;result property=\"password\" column=\"author_password\"/&gt; &lt;result property=\"email\" column=\"author_email\"/&gt; &lt;result property=\"bio\" column=\"author_bio\"/&gt; &lt;result property=\"favouriteSection\" column=\"author_favourite_section\"/&gt;&lt;/association&gt; 一对多的映射 123&lt;collection property=\"tags\" ofType=\"Tag\" &gt; &lt;id property=\"id\" column=\"tag_id\"/&gt;&lt;/collection&gt; sql – 可被其它语句引用的可重用语句块。 insert – 映射插入语句。 update – 映射更新语句。 delete – 映射删除语句。 select – 映射查询语句 动态sql 本质上是sql的拼接 可以通过sql、when、if、foreach等标签进行控制 if：满足条件就拼接12345678&lt;select id=\"findActiveBlogWithTitleLike\" resultType=\"Blog\"&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;if test=\"title != null\"&gt; AND title like #&#123;title&#125; &lt;/if&gt;&lt;/select&gt; choose、when、otherwise：只满足其中的一个条件123456789101112131415&lt;select id=\"findActiveBlogLike\" resultType=\"Blog\"&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;choose&gt; &lt;when test=\"title != null\"&gt; AND title like #&#123;title&#125; &lt;/when&gt; &lt;when test=\"author != null and author.name != null\"&gt; AND author_name like #&#123;author.name&#125; &lt;/when&gt; &lt;otherwise&gt; AND featured = 1 &lt;/otherwise&gt; &lt;/choose&gt;&lt;/select&gt; where：去处第一个满足条件的查询中的and关键字123456789101112131415&lt;select id=\"findActiveBlogLike\" resultType=\"Blog\"&gt; SELECT * FROM BLOG &lt;where&gt; &lt;if test=\"state != null\"&gt; state = #&#123;state&#125; &lt;/if&gt; &lt;if test=\"title != null\"&gt; AND title like #&#123;title&#125; &lt;/if&gt; &lt;if test=\"author != null and author.name != null\"&gt; AND author_name like #&#123;author.name&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; foreach：对集合进行遍历，尤其是在IN关键字中123456789&lt;select id=\"selectPostIn\" resultType=\"domain.blog.Post\"&gt; SELECT * FROM POST P WHERE ID in &lt;foreach item=\"item\" index=\"index\" collection=\"list\" open=\"(\" separator=\",\" close=\")\"&gt; #&#123;item&#125; &lt;/foreach&gt;&lt;/select&gt; 缓存技术mysql主从复制原理 在每个事物更新数据前，Master服务器在二进制日志中记录这些改变，记录完成后Master服务器通知存储引擎提交事务； Slave服务器将Master服务器的日志复制到其中继日志（Relay log）。首先Slave开始一个工作线程I/O，I/O线程在Master上打开一个连接，开始Binary log dump process，Binary log dump process从Master二进制日志中读取时间，如果已经跟上Master，它会睡眠等待Master产生的新事件。I/O线程将这些时间写入 SQL slave thread（SQL从线程）从中继日志中读取事件，并重放其中的事件从而更新Slave上的数据，使其与Master一致，只要该线程与I/O线程保持一致，中继日志通常会位于系统的缓存中，所以中继日志开销很小。 mysql读写分离原理 读写分离就是在主服务器上写，只在从服务器上读。基本原理是让主数据库处理事务性查询，而从数据库处理select查询。数据库复制被用来把事务性查询导致的变更同步到群集中的数据库。 基于中间代理层实现：代理一般位于客户端和服务端之间，代理服务器接到客户端请求通过判断转发到后端数据库，这部分通过Amoeba实现。","categories":[],"tags":[]},{"title":"mysql远程连接","slug":"mysql远程连接","date":"2020-10-16T12:27:10.000Z","updated":"2020-10-16T13:00:01.777Z","comments":true,"path":"2020/10/16/mysql远程连接/","link":"","permalink":"http://yoursite.com/2020/10/16/mysql远程连接/","excerpt":"","text":"3306 端口 此前确保3306端口是打开的(服务器防火墙) 在服务器中查看端口状态 1netstat -an|grep 3306 如果仅仅出现👇下面的信息,则说明3306端口仅仅对localhost开放,外网是无法访问的 1tcp 0 0 0.0.0.0:3306 0.0.0.0:* LISTEN 你需要找到mysql.cnf mysql 的配置文件,有可能不止一个,且不一定和我的文件名一样, 找到.cnf配置文件中的,将其注释 1#bind-address = 127.0.0.1 如果像我这样,就说明端口是开放的,且已经有主机连接 mysql用户权限 在mysql的mysql表中,有用户信息 查看你的用户是否允许,除localhost以外的ip访问 1select host,user from user; 如图,想要外网访问的用户,其对应的host应该是外网ip 如果想要任意ip访问,其对应的host设置为“%” 或者你可以直接创建一个新用户,给他权限 12grant all on database_name.* to user_name@&apos;%&apos; identified by &apos;user_password&apos;;flush privileges;","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"ubuntu自动换源","slug":"ubuntu自动换源","date":"2020-07-09T04:59:50.000Z","updated":"2020-07-09T05:00:41.196Z","comments":true,"path":"2020/07/09/ubuntu自动换源/","link":"","permalink":"http://yoursite.com/2020/07/09/ubuntu自动换源/","excerpt":"","text":"下载huanyuan.sh1git clone git@github.com:huzai9527/ubuntu_huanyuan.git 进入文件夹1sudo bash huanyuan.sh 期间需要你输入管理员密码","categories":[],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://yoursite.com/tags/ubuntu/"}]},{"title":"python网络编程","slug":"python网络编程","date":"2020-07-08T03:46:04.000Z","updated":"2020-10-16T12:40:24.047Z","comments":true,"path":"2020/07/08/python网络编程/","link":"","permalink":"http://yoursite.com/2020/07/08/python网络编程/","excerpt":"","text":"套接字类型面向连接的套接字- 基于TCP/IP，使用SOCKET_STREAM作为套接字类型 无连接的套接字- 基于UDP/IP，使用SOCKET_DGRAM作为套接字类型 pyhton中的网络编程socket模块1socket(socket_family, socket_type, protocol = 0) 其中socket_family 是选择网络类型,本地网（AF_UNIX）还是因特网(AF_INET) socket_type 是选择套接字的类型, protocaol默认为0 套接字对象常用的方法 服务器套接字123s.bind() #将主机号端口号绑定到套接字上s.listen() #设置并启动TCP监听器s.accept() #被动接受客户端连接 客户端套接字12s.connect() #主动发起TCP服务连接s.connect_ex() #此时会以错误码的形式抛出问题而不是一大串异常 创建一个时间戳服务器12345678910111213141516171819202122from socket import *from time import ctimeHOST = ''PORT = 23456ADDR = (HOST, PORT)BUFSIZE = 1024tcpSerSocket = socket(AF_INET,SOCK_STREAM)tcpSerSocket.bind(ADDR)tcpSerSocket.listen(5)while True: print(\"waiting for connection ...\") tcpCliSocket, addr = tcpSerSocket.accept() print(\"connected from:\", addr) while True: data = tcpCliSocket.recv(BUFSIZE) if not data: break tcpCliSocket.send(data+b' time now:'+bytes(ctime(), 'utf-8')) tcpCliSocket.close()tcpSerSocket.close() 创建一个客户机1234567891011121314from socket import *from time import ctimeHOST = \"192.168.0.118\"PORT = 23456ADDR = (HOST, PORT)BUFSIZE = 1024tcpCliSocket = socket(AF_INET, SOCK_STREAM)tcpCliSocket.connect(ADDR)while True: data = input('&gt; ') if not data: break","categories":[],"tags":[{"name":"网络编程 python","slug":"网络编程-python","permalink":"http://yoursite.com/tags/网络编程-python/"}]},{"title":"docker常用命令","slug":"docker常用命令","date":"2020-07-01T04:53:24.000Z","updated":"2020-07-03T04:49:37.734Z","comments":true,"path":"2020/07/01/docker常用命令/","link":"","permalink":"http://yoursite.com/2020/07/01/docker常用命令/","excerpt":"","text":"docker command help1docker command --help use imageslist images1docker images start container by image1docker run -t -i ubuntu:16.04 /bin/bash search images1docker search mysql get new images1docker pull ubuntu:18.04 delete image1docker rmi ubuntu:18.04 [more operations][https://www.runoob.com/docker/docker-image-usage.html] use containerstart container1docker run -t -i ubuntu:16.04 /bin/bash ## -d background show containers1docker ps -a stop &amp; start &amp; restart container123docker start container_id ## RUN IN THE BACKGROUNDdocker stop container_iddocker restart container_id enter container1docker attach container_id ## use exit will stop container 1docker exec -it container_id /bin/bash ## use exit will not stop container export container1docker export container_id &gt; container.tar import container_snap to image1cat docker/mysql.tar | docker import - mysql:v1 delete container1docker rm -f container_id show container’s port mapping1docker port container_id connect container by port mapping1docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD = 123456 mysql connect containerscreate a docker network1docker network create -d bridge hadoop-net show networks1docker network ls run a container and connect to the network1docker run -itd --name hadoop1 --network hadoop-net ubuntu /bin/bash","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}]},{"title":"测试异地管理","slug":"测试异地管理","date":"2020-06-30T12:37:13.000Z","updated":"2020-07-01T05:35:35.561Z","comments":true,"path":"2020/06/30/测试异地管理/","link":"","permalink":"http://yoursite.com/2020/06/30/测试异地管理/","excerpt":"","text":"test","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-06-30T12:29:17.397Z","updated":"2020-06-30T12:29:17.397Z","comments":true,"path":"2020/06/30/hello-world/","link":"","permalink":"http://yoursite.com/2020/06/30/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"数据分析----数据清洗","slug":"数据分析-数据清洗","date":"2019-01-20T00:03:42.000Z","updated":"2020-06-30T12:29:17.403Z","comments":true,"path":"2019/01/20/数据分析-数据清洗/","link":"","permalink":"http://yoursite.com/2019/01/20/数据分析-数据清洗/","excerpt":"","text":"数据分析—-数据清洗一、导入数据1234import pandas as pdimport numpy as npfrom pandas import Series,DataFrameimport xlrd 12df = DataFrame(pd.read_excel('datas/grades.xlsx')) print(df) Unnamed: 0 Unnamed: 1 Unnamed: 2 Unnamed: 3 0 蒋广佳 43.0 69.0 61.0 1 廖菲 80.0 64.0 62.0 2 沈秀玲 68.0 74.0 98.0 3 韦丹 48.0 53.0 64.0 4 张梦雅 72.0 73.0 96.0 5 赵雅欣 60.0 NaN 70.0 6 曹海广 74.0 60.0 20.0 7 陈泽灿 38.0 21.0 92.0 8 NaN 88.0 67.0 84.0 9 高海亮 86.0 74.0 96.0 10 顾晓冬 84.0 60.0 90.0 11 侯星宇 64.0 111.0 NaN 12 江宜哲 60.0 33.0 70.0 13 NaN NaN NaN NaN 14 梁杨杨 68.0 54.0 94.0 15 刘辉 NaN 63.0 98.0 16 罗嘉豪 39.0 44.0 56.0 17 施亚君 90.0 63.0 90.0 18 孙添 64.0 63.0 78.0 19 王杰 74.0 NaN 76.0 20 王泽 52.0 48.0 94.0 21 NaN 60.0 69.0 74.0 22 杨福程 70.0 49.0 76.0 23 尤澳晨 91.0 67.0 86.0 24 翟佳 78.0 73.0 88.0 25 张旭 100.0 60.0 98.0 26 支星哲 80.0 63.0 100.0 27 邹湘涛 54.0 40.0 90.0 我们可以看见上面的数据是缺少标注的，列名缺少标注；并且有很多是空值，因此我们要对数据进行清洗，提高数据的质量。在这里数据清洗有四个要点简称“完全合一” 完整性：单条数据是否完整，统计的字段是否完善。 全面性：观察某一列的全部数值，选中一列，我们可以看到最大值，最小值，平均值。我们可以通过常识判断数据是否合理，比如：数据定义、单位标识、数值本身。 合法性：数据的类型、内容、大小的合法性。比如数据中存在非ASCII字符，性别存在未知，总分超过100等。 唯一性：数据是否存在重复记录，由于数据来源于不同的渠道，重复的情况是非常常见的。行数据、列数据都需要是唯一的。 事实上数据清洗的标准有差不多七八条，有兴趣的可以了解一下，这里归纳为“完全合一”四条，按照这四条基本上可以解决数据清洗中的大部分问题，使得数据标准、干净、连续。 二、开始数据清洗1、完整性problem 1:空行 solution: 删除 1df.dropna(how=\"all\",inplace=True) problem 2:缺失值 solution： 删除：删除数据缺失的记录 均值：使用当前列的均值 高频：使用当前列出现平率最高的数据 首先我们先把列的标注补上 1df = df.rename(columns=&#123;'Unnamed: 0':'index','Unnamed: 1':'math','Unnamed: 2':'english','Unnamed: 3':'c++'&#125;) 1df = df.drop(columns='index') 1print(df) math english c++ 0 43.0 69.0 61.0 1 80.0 64.0 62.0 2 68.0 74.0 98.0 3 48.0 53.0 64.0 4 72.0 73.0 96.0 5 60.0 NaN 70.0 6 74.0 60.0 20.0 7 38.0 21.0 92.0 8 88.0 67.0 84.0 9 86.0 74.0 96.0 10 84.0 60.0 90.0 11 64.0 111.0 NaN 12 60.0 33.0 70.0 14 68.0 54.0 94.0 15 NaN 63.0 98.0 16 39.0 44.0 56.0 17 90.0 63.0 90.0 18 64.0 63.0 78.0 19 74.0 NaN 76.0 20 52.0 48.0 94.0 21 60.0 69.0 74.0 22 70.0 49.0 76.0 23 91.0 67.0 86.0 24 78.0 73.0 88.0 25 100.0 60.0 98.0 26 80.0 63.0 100.0 27 54.0 40.0 90.0 现在我们想对df[‘math’]中缺失的值用平均值代替 1df['math'].fillna(df['math'].mean(),inplace=True) 1print(df) math english c++ 0 43.000000 69.0 61.0 1 80.000000 64.0 62.0 2 68.000000 74.0 98.0 3 48.000000 53.0 64.0 4 72.000000 73.0 96.0 5 60.000000 NaN 70.0 6 74.000000 60.0 20.0 7 38.000000 21.0 92.0 8 88.000000 67.0 84.0 9 86.000000 74.0 96.0 10 84.000000 60.0 90.0 11 64.000000 111.0 NaN 12 60.000000 33.0 70.0 13 68.653846 NaN NaN 14 68.000000 54.0 94.0 15 68.653846 63.0 98.0 16 39.000000 44.0 56.0 17 90.000000 63.0 90.0 18 64.000000 63.0 78.0 19 74.000000 NaN 76.0 20 52.000000 48.0 94.0 21 60.000000 69.0 74.0 22 70.000000 49.0 76.0 23 91.000000 67.0 86.0 24 78.000000 73.0 88.0 25 100.000000 60.0 98.0 26 80.000000 63.0 100.0 27 54.000000 40.0 90.0 如果想用最高频率的数据对english进行填充，可以通过value_counts获取math字段最高频次english_maxf,然后对其进行填充 1english_maxf = df['english'].value_counts().index[0] 1df['english'].fillna(english_maxf,inplace=True) 1print(df) math english c++ 0 43.000000 69.0 61.0 1 80.000000 64.0 62.0 2 68.000000 74.0 98.0 3 48.000000 53.0 64.0 4 72.000000 73.0 96.0 5 60.000000 63.0 70.0 6 74.000000 60.0 20.0 7 38.000000 21.0 92.0 8 88.000000 67.0 84.0 9 86.000000 74.0 96.0 10 84.000000 60.0 90.0 11 64.000000 111.0 NaN 12 60.000000 33.0 70.0 13 68.653846 63.0 NaN 14 68.000000 54.0 94.0 15 68.653846 63.0 98.0 16 39.000000 44.0 56.0 17 90.000000 63.0 90.0 18 64.000000 63.0 78.0 19 74.000000 63.0 76.0 20 52.000000 48.0 94.0 21 60.000000 69.0 74.0 22 70.000000 49.0 76.0 23 91.000000 67.0 86.0 24 78.000000 73.0 88.0 25 100.000000 60.0 98.0 26 80.000000 63.0 100.0 27 54.000000 40.0 90.0 2、全面性problem：列数据单位不统一solution：将不同的单位的找出来，将其进行迭代替换，比如说将榜（lbs）转化为千克（kgs） 12345678# 获取 weight 数据列中单位为 lbs 的数据rows_with_lbs = df['weight'].str.contains('lbs').fillna(False)print df[rows_with_lbs]# 将 lbs 转换为 kgs, 2.2lbs=1kgsfor i,lbs_row in df[rows_with_lbs].iterrows(): # 截取从头开始到倒数第三个字符之前，即去掉 lbs。 weight = int(float(lbs_row['weight'][:-3])/2.2) df.at[i,'weight'] = '&#123;&#125;kgs'.format(weight) 3、合理性problem:非ASCII字符solution:对于非ASCII字符，我们可以采用删除或者替换的方式，我们直接选择删除 1df['name'].replace(&#123;r'[^\\x00-\\x7f]+':''&#125;,regex=True,inplace=True) 4、唯一性problem1：一列有多个参数solution：比如英文名字，是有两部分组成的，包含两个参数Firstname、Lastnamr，我们需要将name一列拆分为Firstname和Lastname两个字段，我们可以采用split方法，对其进行切分 12df['First_namr','Last_name'] = df['name'].str.split(expand=True)df.drop('name',axis=1,inplace=True) problem2:重读数据solution：我们校验数据是否存在重复数据，如果有重复数据，如果就用pandas提供的drop_duplicates()来删除重复数据。 1df.drop_duplicates(['First_name','Last_name'],inplace=True)","categories":[],"tags":[{"name":"数据分析","slug":"数据分析","permalink":"http://yoursite.com/tags/数据分析/"}]},{"title":"爬取网易云热评并生成词云","slug":"爬取网易云热评并生成词云","date":"2019-01-12T02:06:39.000Z","updated":"2020-06-30T12:29:17.403Z","comments":true,"path":"2019/01/12/爬取网易云热评并生成词云/","link":"","permalink":"http://yoursite.com/2019/01/12/爬取网易云热评并生成词云/","excerpt":"","text":"分析热评的请求URL 首先我们先对请求抓包，发现所有的评论都包含在 https://music.163.com/weapi/v1/resource/comments/R_SO_4_32785700?csrf_token=&quot;里面，然后再去分析这个请求，发现这是一个POST请求，请求参数由两个params以及encSecKey。好了到此我们需要的东西都有了，接下来我们分析如何去得到这两个参数。 找到请求 分析请求参数 分析js加密 找到全局js文件，找到两个参数所在的位置 发现这两个参数是由window.asrsea获得的，接着去定位到这个函数找到对应的原函数d 对js进行调试，发现d的四个参数，有三个是定值，这个函数还用到了a、b、c三个函数 其中a是产生一个16位的随机数（这里我直接让它等于FwtEYduOXlNEHbLP）为什么要等与这个呢 hhh 因为我发现这个随机数，他在生成encText的时候用了一次，生成encSecKey的时候，又用了一次，而且encSecKey就只跟这个随机数相关，所以让这个随机数为定值的话，就可以直接得到encSecKey的值，不用再去搞一个rsa加密，为了让你们看清楚，我还是把贴出来把 b函数就是我们主要要解决的AES加密，经过调试，我们可以知道它的两个参数a、b分别是加密字符转、密钥。以及AES的偏移量为0102030405060708、加密模式为CBC 接下来看c函数，c函数其实是RSA加密，获取encSecKey的值的他的三个参数，只有a是变量，是我们随机生成的16为随机数，这里我们就默认为定值，b、c应该是和rsa加密有关的参数，应为本身并没有学过加密，这里我就不多说了，但是经过调试，我们可以知道b、c是定值 b =010001 c是一大串字符串。见下图。 最后我们具体分析一下d函数，经过N次调试，我发现这其实和我的想法差不多，h是一个字典，包含了我们需要的两个参数。encText是由两次AES加密产生的及两次b，加密字符串是一样的，然后密钥第一次是个定值0CoJUm6Qyw8W8jud，第二次是16位随机数，也相当于定值。所以encText就出来了，params是由一次RSA加密产生的，并且只与16位的随机数有关，这里就清楚为什么我让随机数直接等于FwtEYduOXlNEHbLP，哈哈。因为我调试的时候，刚好出现了这么个随机数，于是我就直接拿过来用了，这个随机数对应的encSecKey = 81e7a41af9830200d5606be1a632e57eb0006b3cdae579127115c6323d4c4802f3af9efcee21d9f4126dde266773cbd795f19ae44028f9f8d038cd62d2816952fa99bb61ecb5fba87d5b178ff4b982ee34c7491808f7cb774554a0235a210caf2e5e867a0e2ebdf6f994be1b198ab43b14ce1f7cfa6f80b9070dea5fc5d6c712 用python重写js加密 经过js加密码的分析，我用python实现了一下AES加密，具体代码如下，包含两个参数，一个是需要加密的字符串，一个是密钥具体如下 1234567def AES_encrypt(text, key): pad = 16 - len(text) % 16 text = text + pad * chr(pad) encryptor = AES.new(key, AES.MODE_CBC, \"0102030405060708\") encrypt_text = encryptor.encrypt(text) encrypt_text = base64.b64encode(encrypt_text) return encrypt_text 两次调用这个函数。得到结果与调试的结果对比，一模一样。哈哈，上代码、上图 1234f_key = \"0CoJUm6Qyw8W8jud\"text = \"&#123;\\\"rid\\\":\\\"R_SO_4_32785700\\\",\\\"offset\\\":\\\"20\\\",\\\"total\\\":\\\"true\\\",\\\"limit\\\":\\\"20\\\",\\\"csrf_token\\\":\\\"\\\"&#125;\"rs = AES_encrypt(text, f_key)params = AES_encrypt(str(rs)[2:-1], \"FwtEYduOXlNEHbLP\") 这里解释一下，text是我进过N次调试得出的，因为在请求评论之前，text有好几个值来验证其他的东西，这里我大概理解了一下text的含义，这里我们只要知道offset是偏移量，limit是每次请求多少条，比如你请求前二十条则offset=0，limit = 20，我上面的是请求20-40条。 然后直接获取的encSecKey直接赋值就好啦，结合这两个参数，我们的请求参数就构造好了，直接POST吧，就能得到评论啦，哈哈，上代码，上图 1234567891011121314 data = &#123; 'params': params, 'encSecKey': encSecKey&#125;headers = &#123; 'Accept-Language':\"zh-CN,zh;q=0.9,en;q=0.8\", 'User-Agent':'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.89 Safari/537.36', 'Cookie': 'appver=1.5.0.75771', 'Referer': 'http://music.163.com/'&#125;url = \"https://music.163.com/weapi/v1/resource/comments/R_SO_4_32785700?csrf_token=\"raw = requests.post(url,headers=headers, data=data)print(raw.json()) 解析json，获取评论","categories":[],"tags":[]},{"title":"git简单指令","slug":"git简单指令","date":"2018-12-25T01:02:58.000Z","updated":"2020-06-30T12:29:17.396Z","comments":true,"path":"2018/12/25/git简单指令/","link":"","permalink":"http://yoursite.com/2018/12/25/git简单指令/","excerpt":"","text":"git简单指令首先放一张学习路线 1、创建版本库123mkdir huzai //创建一个空目录cd huzai //进入此目录git init //初始化git仓库 2、添加文件到版本库12git add file //将文件添加到缓存区git commit -m \"post message\" //提交并附带提交信息 3、版本回退123git reset --hard HEAD^ //HEAD是一个指针，指向当前的版本,^代表上一代版本，HEAD^^代表上两代git reflog //查询每次提交的commit_idgit reset --hard commit_id //根据id进行回退 4、管理修改1git diff HEAD -- file //查看工作区（file）与最新版本（HEAD）的区别 5、撤销修改1234git checkout -- file //直接丢弃工作区的修改（可用于恢复误删的文件）//对于已经添加到缓存的修改git reset HEAD file //撤销缓存区的修改git checkout -- file 6、删除文件123rm file //删除本地文件git rm file //删除版本库中的文件git commit -m \"post delete\" //提交删除事务 7、连接远程仓库1234567//先生成连接密钥ssh-kengen -t rsa -C username//将id_rsa.pub中的内容复制到github的密钥管理中//再根据github的提示将本地仓库与远程仓库进行关联git remote add origin git@github.com:username/repository//再推送master分支的所有内容到远程仓库git push -u origin master 8、从远程仓库进行下载1git clone git@github.com:username/repository 9、创建新的分支并切换到该分支下123git checkout -b branchname //创建并切换git branch branch_name //创建git checkout branch_name //切换 10、合并指定分支到当前分支1git merge branch_name 11、删除分支1git branch -d branch_name 12、如果合并时出现冲突12cat conflic_filename//git 会用&lt;&lt;&lt;&lt;&lt; ===== &gt;&gt;&gt;&gt;&gt;&gt;显示不同分支的内容，你则需要手动解决冲突 13、分支管理策略master分支应该是非常稳定的，也就是用于发布最新版本的，平时不应该在上面干活，干活都应该在dev分支上也就是说dev分支是不稳定的，到了某个时候将dev分支合并到master分支上，你和你的小伙伴应该在各自的分支上干活，然后推送到dev分支上 14、bug分支1234git add now_filegit stash //保护现场//这里修改buggit stash pop //提取现场，继续工作 15、丢弃一个没有被合并的分支1git branch -D branch_name 16、多人协作 1、尝试git push origin branch_name 2、如果推送失败，说明远程分支比你的版本新，则你git pull 拉取远程文件 3、合并你两的分支，如果有冲突则手动解决问题 4、重复1 注：如果git pull 提示 no tracking information 则说明远程分支和本地分支没有关联用下面的命令进行关联1git branch --set-uostream-to branch_name origin/branch_name 或者你不知道有什么分支123git remote -v //查看远程仓库的信息git checkout -b branch_name origin/branch_name //创建本地分支以及远程分支git branch --set-upstream-to branch_name origin/branch_name //进行关联","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"数据分析-pandas","slug":"数据分析-pandas","date":"2018-12-25T00:21:06.000Z","updated":"2020-06-30T12:29:17.399Z","comments":true,"path":"2018/12/25/数据分析-pandas/","link":"","permalink":"http://yoursite.com/2018/12/25/数据分析-pandas/","excerpt":"","text":"数据分析—-pandas核心数据结构 Series &amp; DataFrame123import pandas as pdimport numpy as npfrom pandas import Series, DataFrame Series是一个定长的字典序列，它有两个基本属性index 、 value index 默认是 0 ,1,2,3 递增的，也可以自己指定索引 index=[‘a’, ‘b’, ‘c’]创建Series的三种方式1234567x1 = Series([1,2,3,4])x2 = Series(data=[1,2,3,4],index=['a','b','c','d'])dic = &#123;'a':1,'b':2,'c':3,'d':4&#125;x3 = Series(dic)print(x1)print(x2)print(x3) 0 1 1 2 2 3 3 4 dtype: int64 a 1 b 2 c 3 d 4 dtype: int64 a 1 b 2 c 3 d 4 dtype: int64 DataFrame类似数据库中的表，可以将其看成是由有相同的索引的Series组成创建DataFra几种方式123data = &#123;\"chinese\":[90,80,70,60,50],'math':[70,80,70,90,60],'english':[30,50,70,80,60]&#125;df1 = DataFrame(data=data,index=['zhangfei','guanyu','zhaoyun','huangzhong','machao'])print(df) chinese english math zhangfei 90 30 70 guanyu 80 50 80 zhaoyun 70 70 70 huangzhong 60 80 90 machao 50 60 60 123import xlrddf2 = DataFrame(pd.read_excel('datas/grades.xlsx'))df2 = df2.drop_duplicates() 1print(df2) 姓名 高数 英语 C++ 0 蒋广佳 43 69 61 1 廖菲 80 64 62 2 沈秀玲 68 74 98 3 韦丹 48 53 64 4 张梦雅 72 73 96 5 赵雅欣 60 63 70 6 曹海广 74 60 20 7 陈泽灿 38 21 92 8 邓杰 88 67 84 9 高海亮 86 74 96 10 顾晓冬 84 60 90 11 侯星宇 64 69 96 12 江宜哲 60 33 70 13 李洪汀 76 56 84 14 梁杨杨 68 54 94 15 刘辉 68 63 98 16 罗嘉豪 39 44 56 17 施亚君 90 63 90 18 孙添 64 63 78 19 王杰 74 60 76 20 王泽 52 48 94 21 徐孟圆 60 69 74 22 杨福程 70 49 76 23 尤澳晨 91 67 86 24 翟佳 78 73 88 25 张旭 100 60 98 26 支星哲 80 63 100 27 邹湘涛 54 40 90 数据清洗删除不必要的行或列123#删除行df2 = df2.drop(columns=['姓名'])print(df2) 高数 英语 C++ 0 43 69 61 1 80 64 62 2 68 74 98 3 48 53 64 4 72 73 96 5 60 63 70 6 74 60 20 7 38 21 92 8 88 67 84 9 86 74 96 10 84 60 90 11 64 69 96 12 60 33 70 13 76 56 84 14 68 54 94 15 68 63 98 16 39 44 56 17 90 63 90 18 64 63 78 19 74 60 76 20 52 48 94 21 60 69 74 22 70 49 76 23 91 67 86 24 78 73 88 25 100 60 98 26 80 63 100 27 54 40 90 123#删除列df2 = df2.drop(index = [27])print(df2) 高数 英语 C++ 0 43 69 61 1 80 64 62 2 68 74 98 3 48 53 64 4 72 73 96 5 60 63 70 6 74 60 20 7 38 21 92 8 88 67 84 9 86 74 96 10 84 60 90 11 64 69 96 12 60 33 70 13 76 56 84 14 68 54 94 15 68 63 98 16 39 44 56 17 90 63 90 18 64 63 78 19 74 60 76 20 52 48 94 21 60 69 74 22 70 49 76 23 91 67 86 24 78 73 88 25 100 60 98 26 80 63 100 重命名列名1df2 = df2.rename(columns=&#123;'高数':'math','英语':'english'&#125;) 去除重复的值1df2 = df2.drop_duplicates() 更改数据格式12df2['math'] = df2['math'].astype('str')#df2['math'].astype(np.int64) 清除数据间的空格12df2['math'] = df2['math'].map(str.strip) #删除左右两边的空格df2['math'] = df2['math'].map(str.lstrip) #删除左边的空格（str.rstrip 右边的空格） 删除指定字符1df2['math'] = df2['math'].str.strip('$') 大小写转换1df2.columns = df2.columns.str.upper() #全部大写（lower（）全部小写 title（）首字母大写） 1df2 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } MATH ENGLISH C++ 0 43 69 61 1 80 64 62 2 68 74 98 3 48 53 64 4 72 73 96 5 60 63 70 6 74 60 20 7 38 21 92 8 88 67 84 9 86 74 96 10 84 60 90 11 64 69 96 12 60 33 70 13 76 56 84 14 68 54 94 15 68 63 98 16 39 44 56 17 90 63 90 18 64 63 78 19 74 60 76 20 52 48 94 21 60 69 74 22 70 49 76 23 91 67 86 24 78 73 88 25 100 60 98 26 80 63 100 使用apply函数对数据进行清洗123#df2['MATH'] = df2['MATH'].apply(str.lower)df2['MATH'] = df2['MATH'].astype(np.int64)df2 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } MATH ENGLISH C++ 0 43 69 61 1 80 64 62 2 68 74 98 3 48 53 64 4 72 73 96 5 60 63 70 6 74 60 20 7 38 21 92 8 88 67 84 9 86 74 96 10 84 60 90 11 64 69 96 12 60 33 70 13 76 56 84 14 68 54 94 15 68 63 98 16 39 44 56 17 90 63 90 18 64 63 78 19 74 60 76 20 52 48 94 21 60 69 74 22 70 49 76 23 91 67 86 24 78 73 88 25 100 60 98 26 80 63 100 1234def plus(df): df['Total'] = df['MATH']+df['ENGLISH']+df['C++'] return dfdf2 = df2.apply(plus,axis=1) 1print(df2) MATH ENGLISH C++ Total 0 43 69 61 173 1 80 64 62 206 2 68 74 98 240 3 48 53 64 165 4 72 73 96 241 5 60 63 70 193 6 74 60 20 154 7 38 21 92 151 8 88 67 84 239 9 86 74 96 256 10 84 60 90 234 11 64 69 96 229 12 60 33 70 163 13 76 56 84 216 14 68 54 94 216 15 68 63 98 229 16 39 44 56 139 17 90 63 90 243 18 64 63 78 205 19 74 60 76 210 20 52 48 94 194 21 60 69 74 203 22 70 49 76 195 23 91 67 86 244 24 78 73 88 239 25 100 60 98 258 26 80 63 100 243 pandas中常用的统计函数 1print(df2.describe()) MATH ENGLISH C++ Total count 27.000000 27.000000 27.000000 27.000000 mean 69.444444 59.703704 81.148148 210.296296 std 16.113380 12.406000 17.933003 34.410212 min 38.000000 21.000000 20.000000 139.000000 25% 60.000000 55.000000 72.000000 193.500000 50% 70.000000 63.000000 86.000000 216.000000 75% 80.000000 68.000000 95.000000 239.500000 max 100.000000 74.000000 100.000000 258.000000 12","categories":[],"tags":[{"name":"数据分析","slug":"数据分析","permalink":"http://yoursite.com/tags/数据分析/"}]},{"title":"数据分析----numpy ","slug":"数据分析-numpy","date":"2018-12-22T23:21:29.000Z","updated":"2020-06-30T12:29:17.399Z","comments":true,"path":"2018/12/23/数据分析-numpy/","link":"","permalink":"http://yoursite.com/2018/12/23/数据分析-numpy/","excerpt":"","text":"数据分析—numpy12import pandas as pdimport numpy as np 创建普通数组12a = np.array([1,2,3])b = np.array([[1,2,3],[4,5,6],[7,8,9]]) 1b[1,1] = 10 1234print(a.shape)print(b.shape)print(a.dtype)print(b) (3,) (3, 3) int64 [[1 2 3] [4 5 6] [7 8 9]] 创建结构数组1234567personalType = np.dtype(&#123; 'names':['name','age','chinese','math','english'], 'formats':['S25','i','i','i','f']&#125;)students = np.array([(\"huzai\",22,99,99,99.5),(\"huzai\",22,99,99,99.5)],dtype=personalType)age = students[:]['age']print(np.mean(age)) 22.0 1print(students) [(b&apos;huzai&apos;, 22, 99, 99, 99.5) (b&apos;huzai&apos;, 22, 99, 99, 99.5)] 创建连续数组12x1 = np.arange(1,11,2) #步长为2，从1开始的等差数组(不包括终值)x2 = np.linspace(1,9,5) #将1-9分成5块，结果如上 12print(x1)print(x2) [1 3 5 7 9] [1. 3. 5. 7. 9.] 数组间的算数运算1234print(np.add(x1,x2))print(np.subtract(x1,x2))print(np.multiply(x1,x2))print(np.divide(x1,x2)) [ 2. 6. 10. 14. 18.] [0. 0. 0. 0. 0.] [ 1. 9. 25. 49. 81.] [1. 1. 1. 1. 1.] 统计函数数组中的最值 np.amin() amax()1234a = np.array([[1,3,7],[2,5,8],[6,4,9]])print(np.amin(a))print(np.amin(a,0)) #每一列的最小值print(np.amin(a,1)) #每行的最小值 1 [1 3 7] [1 2 4] 统计最大值与最小值之差 ptp()123print(np.ptp(a))print(np.ptp(a,0)) #每列最大值与最小值的差print(np.ptp(a,1)) #每行最大值与最小值的差 8 [5 2 2] [6 6 5] 统计数组的百分位数 percentile(a, p, axis) a:数组名 p 代表百分比 axis代表是行还是列123print(np.percentile(a,50))print(np.percentile(a,50,0))print(np.percentile(a,50,1)) 5.0 [2. 4. 8.] [3. 5. 6.] 统计数组中的中位数以及平均数 median() mean()123print(np.median(a))print(np.median(a,0))print(np.median(a,1)) 5.0 [2. 4. 8.] [3. 5. 6.] 数组中的加权平均值 average(a,weights)1234b = np.array([1,2,3,4])wts = np.array([1,2,3,4])print(np.average(b))print(np.average(b,weights=wts)) 2.5 3.0 统计数组中的标准差（std（））与方差（var（））12print(np.std(b))print(np.var(b)) 1.118033988749895 1.25 Numpy排序123print(a)print(np.sort(a))print(np.sort(a,0)) [[1 3 7] [2 5 8] [6 4 9]] [[1 3 7] [2 5 8] [4 6 9]] [[1 3 7] [2 4 8] [6 5 9]] 作业题123456st_type = np.dtype(&#123; 'names':['name','chinese','english','math'], 'formats':['S25','i','i','i']&#125;)grades = np.array([('zhangfei',66,65,30),('guanyu',95,85,98),('zhaoyun',93,92,96),('huangzhong',90,88,77), ('dianwei',80,90,90)],dtype=st_type) 1print(grades) [(b&apos;zhangfei&apos;, 66, 65, 30) (b&apos;guanyu&apos;, 95, 85, 98) (b&apos;zhaoyun&apos;, 93, 92, 96) (b&apos;huangzhong&apos;, 90, 88, 77) (b&apos;dianwei&apos;, 80, 90, 90)] 1234chinese = grades[:]['chinese'] english = grades[:]['english']math = grades[:]['math']total = np.add(chinese,english,math) 1print(total) [131 180 185 178 170] 1c_a,e_a,m_a = np.average(chinese),np.average(english),np.average(math) 1print(c_a) 84.8 12","categories":[],"tags":[{"name":"数据分析","slug":"数据分析","permalink":"http://yoursite.com/tags/数据分析/"}]},{"title":"小说更新后发送邮箱的问题解决","slug":"小说更新后发送邮箱的问题解决","date":"2018-11-23T08:54:00.000Z","updated":"2020-06-30T12:29:17.397Z","comments":true,"path":"2018/11/23/小说更新后发送邮箱的问题解决/","link":"","permalink":"http://yoursite.com/2018/11/23/小说更新后发送邮箱的问题解决/","excerpt":"","text":"遇到的问题 先上一张图，看一下问题在哪 从图上我们可以看到，虽然小说是每天发两次给我，但是有时候会漏掉一章，有时候又会重复发一章，这都是小说作者不按时更新惹的祸啊！！！既然小说作者的习惯改变不了，那就完善自我吧! 新的思路，加一个“缓存”缓存是什么意思呢？ 本地建一个名为origin.txt的文本文件，每次爬取完成后与origin.txt里面的内容对比一下。 如果一样则不发送。 如果不一样就发送，并且将最新的内容保存到origin.txt文件中，作为下一次的对照。 演示效果 再origin.txt里写入test，然后启动我们可以看到，origin文件已被重新写入，并且新的文本已经发送到邮箱 再次启动，也就是还没跟新的情况我们看到，提示消息，这里不会跟新origin，也不会发送邮件 还遗留的问题 如果作者一下爆发怎么办（一分钟更新十章！）思考一下，其实原理差不多，缓存大小不同罢了！有兴趣的可以尝试一下！项目源码已发布在githubhttps://github.com/huzai9527/fictionSend","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"c++指针问题","slug":"c-指针问题","date":"2018-11-19T08:27:20.000Z","updated":"2020-06-30T12:29:17.395Z","comments":true,"path":"2018/11/19/c-指针问题/","link":"","permalink":"http://yoursite.com/2018/11/19/c-指针问题/","excerpt":"","text":"指针究竟是什么 指针是一类特殊的变量，他保存的不是一般数据的值，而是程序中另一对象在内存中的地址我们先通过一个小程序看一看指针如何工作1234567891011#include &lt;iostream&gt;using namespace std;int main()&#123; int n = 123,m = 456; int *p = &amp;n; cout&lt;&lt;\"&amp;n:\"&lt;&lt;&amp;n&lt;&lt;endl; cout&lt;&lt;\"&amp;p:\"&lt;&lt;&amp;p&lt;&lt;endl; cout&lt;&lt;\" p:\"&lt;&lt;p&lt;&lt;endl; cout&lt;&lt;\"*p:\"&lt;&lt;*p&lt;&lt;endl; return 0;&#125; 从运行结果可以看出下面几点： p本身是有一个地址的且地址为 &amp;p p的值是另一个变量n的地址 &amp;n *p所表示的意思是地址为 p 的内存中所存的值 n 即本段程序中共涉及到2个地址，一个是 n 的地址，一个是 p 的地址,我们用一张图来表示他们的关系指针的初始化 被具有相同类型的对象初始化 12int i = 10;int *p = &amp;i; 由另一个同一类型的指针初始化,这时两个指针指向同一地址空间 1int *p1 = p; 通过直接分配内存地址得到初值 1int *p2 = new int; 指针也可以没有类型，通用指针的定义,这样的指针可以指向任一对象 1void *p3 指针的运算符定义指针的目的事通过指针变量间接的访问变量 *:取指针值运算符。通过指针所指内存单元的地址间接的访问对应的存储单元。若指针变量p指向变量a，则 *p的运算结果为变量a的值 &amp;:取地址运算符。返回变量对应的存储单元地址，若a为int变量，p为int型指针变量，则 p = &amp;a表示将a的存储单元地址赋给p。用一个程序验证一下： 12345678910111213#include &lt;iostream&gt;using namespace std;int main()&#123; int a = 100; int *p,*p1,*q; p = &amp;a; p1 = p; q = NULL; cout&lt;&lt;\"a=\"&lt;&lt;a&lt;&lt;\",\"&lt;&lt;\"*p=\"&lt;&lt;*p&lt;&lt;\",\"&lt;&lt;\"p=\"&lt;&lt;p&lt;&lt;endl; *p1 = 200; cout&lt;&lt;\"a=\"&lt;&lt;a&lt;&lt;\",\"&lt;&lt;\"*p=\"&lt;&lt;*p&lt;&lt;\",\"&lt;&lt;\"p=\"&lt;&lt;p&lt;&lt;endl; cout&lt;&lt;\"*p1=\"&lt;&lt;*p1&lt;&lt;\",\"&lt;&lt;\"p1=\"&lt;&lt;p1&lt;&lt;endl;&#125; 运行结果 指针与数组的关系 数组名和指针在引用数组元素和取他们的地址方面可以相互转换，但两者有一个重要的不同点 数组是在定义时就分配好内存空间的，因此数组名是一个地址常量，在程序中不能将数组名作为变量为其赋值，而指针是一个变量，可以多次赋值我们通过一个程序看一下他们的关系 1234567891011121314#include &lt;iostream&gt;using namespace std;int main()&#123;int a[10]=&#123;1,2,3,4,5,6,7,8,9,10&#125;;int *pa = a;int i = 3;cout&lt;&lt;\"a[i] :\"&lt;&lt;a[i]&lt;&lt;endl;cout&lt;&lt;\"*(pa+i):\"&lt;&lt;*(pa+i)&lt;&lt;endl;cout&lt;&lt;\"*(a+i) :\"&lt;&lt;*(a+i)&lt;&lt;endl;cout&lt;&lt;\"&amp;a[i] :\"&lt;&lt;&amp;a[i]&lt;&lt;endl;cout&lt;&lt;\"a+i :\"&lt;&lt;a+i&lt;&lt;endl;cout&lt;&lt;\"pa+i :\"&lt;&lt;pa+i&lt;&lt;endl; &#125; 运行结果 易重要的和易混淆的概念 为什么要对指针初始化？定义了指针变量后，系统会为其分配一个内存空间，若没有赋值则此内存区域的内容是随机的，也就是指针随机指向一个内存单元。你想想如果你对一个随机的内存空间进行写操作，会怎样！ 指针的运算指针 + 整数 = 指针指针 - 指针 = 整数 //同类行的指针相减表示两个基类型变量的个数指针 + 指针 = ？？？？ //不可以 new、 new[]、 delete、 delete[]有什么区别 1234int *p = new int(3) // 为p分配了一个整形变量的存储区域并初始化为3int *p1 = new int[20] // 分配20个整形变量的区域给p1delete p //释放有new申请的空间delete[] p1 //释放由new[]申请的空间 c++程序中动态分配的内存不会被自动释放 指针函数和函数指针含义相同吗？完全不同！指针函数：若一个函数返回的是一个地址，则称该函数为指针函数。格式是 数据类型 函数名（参数列表）函数指针：指针变量指向一个函数的入口地址，格式为 数据类型 （函数指针变量）（参数列表）函数指针的用法：12345678910111213141516#include &lt;iostream&gt;using namespace std;int cul(int (*pf)(int,int), int x, int y)&#123; return pf(x,y);&#125;int add(int x,int y)&#123; return x+y;&#125;int sub(int x,int y)&#123; return x-y;&#125;int main()&#123; int a=10,b=20; cout&lt;&lt;a&lt;&lt;\"+\"&lt;&lt;b&lt;&lt;\"=\"&lt;&lt;cul(add,a,b)&lt;&lt;endl; cout&lt;&lt;a&lt;&lt;\"-\"&lt;&lt;b&lt;&lt;\"=\"&lt;&lt;cul(sub,a,b);&#125; 常量指针、指针常量、指向常量的指针常量有什么区别常量指针：表示指针指向的是一个常量，格式：const 类型 指针变量 或 类型 const 指针变量1234int i;const int *p = &amp;i;*p = 10; //错误i = 10; //正确 指针常量：表示所定义的指针是一个常量，只能在定义的时候初始化123int i,j;int * const p = &amp;i;p = &amp;j;//错误 指向常量的指针常量：格式为 const 类型 * const 指针常量12345int i,j;const int * const p = &amp;i;*p = 10;//错误p = &amp;j;//错误i = 10;//正确","categories":[],"tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"scrapy构建自己的ip代理池","slug":"scrapy构建自己的ip代理池","date":"2018-11-18T09:33:13.000Z","updated":"2020-06-30T12:29:17.397Z","comments":true,"path":"2018/11/18/scrapy构建自己的ip代理池/","link":"","permalink":"http://yoursite.com/2018/11/18/scrapy构建自己的ip代理池/","excerpt":"","text":"用scrapy爬取可用的代理分析免费代理网站的结构 我爬取了三个字段：IP、port、type分析要爬取的数据，编写items.py 因此在items.py中，建立相应的字段1234567import scrapyclass IproxyItem(scrapy.Item): # define the fields for your item here like: # name = scrapy.Field() ip = scrapy.Field() type = scrapy.Field() port = scrapy.Field() 爬取所有的免费ip 在spider目录下，创建IpSpider.py12345678910111213import scrapyimport Iproxy.itemsclass IpSpider(scrapy.Spider): name = 'IpSpider' allowed_domains = ['xicidaili.com'] start_urls = ['http://www.xicidaili.com/'] def parse(self, response): item = Iproxy.items.IproxyItem() item['ip'] = response.css('tr td:nth-child(2)::text').extract() item['port'] = response.css('tr td:nth-child(3)::text').extract() item['type'] = response.css('tr td:nth-child(6) ::text').extract() yield item 检测是否可用，如果可用则存入数据库 因为是免费的ip，所以我们有必要检测一下他是否可用，对于可用的就存入数据库，反之则丢弃 检测处理数据在pipeline.py中编写 检测原理，通过代理访问百度，如果能够访问，则说明可用1234567891011121314151617181920212223242526272829303132333435363738394041# -*- coding: utf-8 -*-# Define your item pipelines here## Don't forget to add your pipeline to the ITEM_PIPELINES setting# See: https://doc.scrapy.org/en/latest/topics/item-pipeline.htmlimport pymysqlimport requestsclass IproxyPipeline(object): def process_item(self, item, spider): print('@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@') db = pymysql.connect(\"localhost\", \"root\", \"168168\", \"spider\") cursor = db.cursor() for i in range(1, len(item['ip'])): ip = item['ip'][i] + ':' + item['port'][i] try: if self.proxyIpCheck(ip) is False: print('此ip：'+ip+\"不能用\") continue else: print('此ip：'+ip+'可用，存入数据库！') sql = 'insert into proxyIp value (\"%s\")' % (ip) cursor.execute(sql) db.commit() except: db.rollback() db.close() return item def proxyIpCheck(self, ip): proxies = &#123;'http': 'http://' + ip, 'https': 'https://' + ip&#125; try: r = requests.get('https://www.baidu.com/', proxies=proxies, timeout=1) if (r.status_code == 200): return True else: return False except: return False 运行情况 可以看出还是有好多ip不能用的 可用的存在数据库","categories":[],"tags":[{"name":"python scrapy 爬虫","slug":"python-scrapy-爬虫","permalink":"http://yoursite.com/tags/python-scrapy-爬虫/"}]},{"title":"python爬取最新更新的小说并发送到你的邮箱","slug":"python爬取最新更新的小说并发送到你的邮箱","date":"2018-11-17T07:07:29.000Z","updated":"2020-06-30T12:29:17.397Z","comments":true,"path":"2018/11/17/python爬取最新更新的小说并发送到你的邮箱/","link":"","permalink":"http://yoursite.com/2018/11/17/python爬取最新更新的小说并发送到你的邮箱/","excerpt":"","text":"数据获取—Spider()找目标网站，该网站是你看小说的网站，分析该网站的结构方便你对内容的抓取 这里我获取最新章节的时间、标题以及标题的连接 这里获取内容 编写spider方法，确定他的返回值，这里我返回的是一个list，包括更新的时间、标题、内容 方法中需要导入的包 requests bs4 re 12345678910111213141516171819202122def spider(): list = [] response = requests.get('https://www.xbiquge6.com/13_13134/') response.encoding = ('utf-8') html = response.text html = BeautifulSoup(html, 'html.parser') time = html.select('div#info p:nth-of-type(3)').__getitem__(0).text[5:] title = html.select('div#info p:nth-of-type(4) a[href]').__getitem__(0).text href = html.select('div#info p:nth-of-type(4) a[href]').__getitem__(0) # print(title) pattern = re.compile(r'href=\"(.+?)\"') href = re.findall(pattern, href.__str__()).__getitem__(0) href = \"https://www.xbiquge6.com\" + href response = requests.get(href) response.encoding = ('utf-8') html = BeautifulSoup(response.text, 'html.parser') content = html.select('div#content') # print(content) list.append(title) list.append(content) list.append(time) return list 邮件发送—smtp()首先先在你的邮箱中设置打开smtp服务比如我的QQ邮箱，先进入邮箱-&gt;点击设置-&gt;点击账户-&gt;下滑找到smtp服务-&gt;点击开启服务-&gt;生成授权码（就是你在smtp方法中用到的password）![PCO_6AO93%@2W$B}GFGHI0 (1).png 编写smtp方法，向我的邮箱发送小说，确定返回值是bool类型，成功为True，失败为False12345678910111213141516def mail(): list = spider(); ret = True try: mail_msg = list.__getitem__(1).__str__() msg = MIMEText(mail_msg, 'html', 'utf-8') msg['From'] = formataddr(['huzai', my_sender]) msg['To'] = formataddr(['huzai', receiver]) msg['Subject'] = list.__getitem__(0) server = smtplib.SMTP_SSL('smtp.qq.com', 465) server.login(my_sender, my_pwd) server.sendmail(my_sender, [receiver], msg.as_string()) server.quit() except Exception: ret = False return ret 上传脚本到服务器使用xftp将写好的smtp.py上传到你的云服务器上直接拖进去就行 这里注意保证你的服务器上的python版本和你本机一致，且需要的包已经安装 如果你的服务器上的版本是2.*的可以运行下面代码安装python3123sudo apt-get remove pythonsudo apt-get install python3sudo apt autoremove 用xshell进入服务器试着运行 在服务器端设置定时执行确保你安装了crontab（ubuntu默认安装）cron命名解析：执行的时间 + 执行的用户 + 执行的命令 查看原有的cron1cat /etc/crontab 编辑你的程序1sudo nano /etc/crontab 编写你的命令，每天14:58给我发送邮件，这里根据你看的小说的更新时间设置，一天几更在大约什么时间等等158 14 * * * root python3 smtp.py 编辑好了再次查看cron是否已经写入，我这里已经写入重启crontab服务1service cron restart 静静的等待14:58的到来，查看邮箱 邮件收到了最新更新的哦","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"github+hexo搭建个人博客","slug":"github-hexo搭建个人博客","date":"2018-11-11T09:46:19.000Z","updated":"2020-06-30T12:29:17.396Z","comments":true,"path":"2018/11/11/github-hexo搭建个人博客/","link":"","permalink":"http://yoursite.com/2018/11/11/github-hexo搭建个人博客/","excerpt":"","text":"1.创建的项目名默认为 用户名.github.io,创建时点击生成readme文件，方便后面添加说明 2.在本地创建一个文件夹，我是在E盘创建的blog，推荐用vscode作为编辑器，在编辑器里面打开文件夹，打开Terminer 3.使用hexo初始化文件夹，这一步会产生很多的hexo配置文件，我们先不管，先跑起来 4.运行hexo server打开服务，看看本地能不能显示运行后访问url，如果看到如图就成功了 5.配置文件中填写git的配置信息，按照如下格式填写 6.打开文件夹，右键git bash here 7.输入cd ~/.ssh，进入ssh文件夹 8.配置git中的用户名和邮箱 9.生成ssh密钥 10.在github的项目中加入密钥 11.测试密钥链接是否成功 12.测试成功后再再编辑器中运行hexo clean hexo g hexo d 这样就算上传成功 13.访问你的博客，看到之前再本地运行的界面，就行了","categories":[],"tags":[{"name":"github","slug":"github","permalink":"http://yoursite.com/tags/github/"}]}]}